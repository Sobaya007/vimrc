module model.modelloader.modelloader;

import model.imports;

/+
import model.modelloader.modelloader;

// モデルの読み込み
string path = "Resource/model/◯◯◯.fbx";
ModelLoader loader = new ModelLoader(path);

// 各パラメータの取得(メッシュが一つしかない場合)
vec4[] vertices = loader.getMeshes.front.vertices; // 頂点
vec3[] normals = loader.getMeshes.front.normals; // 法線
vec2[] texCoords = loader.getMeshes.front.texCoords; // テクスチャ座標
uint[] indices = loader.getMeshes.front.indices; // 頂点の順番
vec4 diffuse = loader.getMeshes.front.material.diffuse; // diffuse
vec4 specular = loader.getMeshes.front.material.specular; // specular
vec4 ambient = loader.getMeshes.front.material.ambient; // ambient
TextureObject texture = loader.getMeshes.front.material.texture; // テクスチャ

// 頂点とかをfloat[]の型で欲しいなら次みたいなことをして下さい
import std.algorithm, std.array;
float[] vertices = loader.getMeshes.front.vertices.map!(v => [v.x, v.y, v.z, v.w]).array.join; // 頂点
+/

class ModelLoader {

private:
	bool _isLoaded = false;

	aiScene* _scene;
	Node_Assimp _rootNode;
	Mesh_Assimp[] _meshes;
	Material_Assimp[] _materials;

	static this() {
		DerelictASSIMP3.load();
	}

public:
	this(string path) {
		load(path);
	}

	~this() {
		clear();
	}

	Node_Assimp getRootNode() @nogc {
		return _rootNode;
	}

	Mesh_Assimp[] getMeshes() @nogc {
		return _meshes;
	}

	Material_Assimp[] getMaterials() @nogc {
		return _materials;
	}

private:
	void load(string path) {
		_scene = cast(aiScene*)aiImportFile(
			toStringz(path),
			aiProcess_CalcTangentSpace | aiProcess_Triangulate | aiProcess_JoinIdenticalVertices | aiProcess_SortByPType
		);

		if (_scene) {
			initFromScene(path);
			_isLoaded = true;
		} else {
			auto errorMessage = format("%s", fromStringz(aiGetErrorString()));
			throw new AssetException(errorMessage);
		}
	}

	void initFromScene(string path) {
		_materials.length = _scene.mNumMaterials;
		foreach(i; 0.._scene.mNumMaterials) {
			_materials[i] = new Material_Assimp(_scene.mMaterials[i], path);
		}
		_meshes.length = _scene.mNumMeshes;
		foreach(i; 0.._scene.mNumMeshes) {
			_meshes[i] = new Mesh_Assimp(_scene.mMeshes[i], _materials);
		}
		_rootNode = new Node_Assimp(_scene.mRootNode, _meshes);
	}

	void clear() {
		if (_isLoaded) {
			aiReleaseImport(_scene);
			_isLoaded = false;
		}
	}

}