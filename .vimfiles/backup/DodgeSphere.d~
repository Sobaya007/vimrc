module player.dodge.DodgeSphere;

import std.container;
import collision;
import player;
import player.Constant;
import player.Input;
import player.PlayerCollisionManager;
import player.PlayerDrawer;
import player.ParticleManager;
import player.PlayerShape;
import player.dodge.DodgeState;
import player.dodge.ContactPair;
import sbylib;
import player.elastic;

class DodgeSphere {

  private enum MAX_dodge_RATE = 2;
  private enum MIN_dodge_RATE = 0.7f;

  private DodgeState dodgeState;
  private ParticleManager pManager;
  private PlayerCollisionManager colManager;
  private PlayerShape shape;
  private PlayerDrawer drawer;
  private PhysicalSphere collisionSphere;

  package vec3 gravityPoint;
  package quat orientation;
  package vec3 linearVelocity;
  package vec3 angularVelocity;
  private vec3[] rPos;
  private float[] angles;
  package flim dodgeCount;
  private Array!ContactPair pairs;
  private vec3 direction;
  private float floorY;

  this(DodgeState dodgeState, PlayerDrawer drawer, ParticleManager pManager, PlayerCollisionManager colManager, PlayerShape shape){
    this.dodgeState = dodgeState;
    this.pManager = pManager;
    this.colManager = colManager;
    this.shape = shape;
    this.drawer = drawer;

    this.collisionSphere = new PhysicalSphere(1);
    this.dodgeCount = flim(0,0,1);
  }

  void init() {
    shape.step = &step;
    drawer.nextVertices = &getVertices;
    this.gravityPoint = pManager.getParticles.map!(p => p.position).sum / pManager.getParticles.length;
    this.orientation = quat(0,0,0,1);
    this.linearVelocity = pManager.getParticles.map!(p => p.velocity).sum / pManager.getParticles.length;
    this.angularVelocity = -linearVelocity.cross(vec3(0,1,0)).normalize * linearVelocity.length;
    rPos.length = angles.length = pManager.getParticles.length;
    alias camera = SbyWorld.currentCamera;
    auto cv = camera.getVecX;
    this.direction = -cv;
    this.linearVelocity = linearVelocity * 0.1;
    this.floorY = float.max;
    foreach (i, p; pManager.getParticles) {
      rPos[i] = p.position - gravityPoint;
      rPos[i] = rPos[i].normalize;
      auto xz = rPos[i].dot(cv).abs;
      if (dot(cv, p.position - camera.getPos) < 0) {
        xz *= -1;
      }
      angles[i] = atan2(xz, rPos[i].y);
      floorY = min(floorY, p.position.y);
    }
    floorY++;
    colManager.setCollisionShape(collisionSphere);
    colManager.setUserData(cast(void*)this);
    colManager.setListener(&onCollision);
    dodgeCount = 0;
  }

  void end() {
    foreach (p; pManager.getParticles) {
      p.velocity = vec3(0);
      p.force = p.extForce = vec3(0);
    }
  }

  private void step() {
    dodgeCount += 0.07f;
    //dodge
    alias t = dodgeCount;
    foreach (i, p; pManager.getParticles) {
      rPos[i] = rPos[i].normalize * dodgeTransform(angles[i], dodgeRate());
    }
    //gravity
    linearVelocity += vec3(0,-1,0) * 0.1f * gravity * timeStep;
    //accel
    linearVelocity += direction * 20 * sin(2 * PI * dodgeCount) * any!(a => a.isGround)(pManager.getParticles);
    //collision response
    foreach (k; 0..5) {
      foreach (ref pair; pairs) {
        pair.solve;
      }
    }
    pairs.clear();
    //teikou
    //integral
    gravityPoint += linearVelocity * timeStep;
    //orientation = quat.createAxisAngle(angularVelocity * timeStep) * orientation;
    //apply to particle
    alias ease = s => s * (1-s) * 4;
    foreach (i, p; pManager.getParticles) {
      p.position = rotate(rPos[i], orientation) + gravityPoint;
      p.position.y -= floorY;
      p.position.y *= 1-ease(t) * 0.1;
      p.position.y += floorY;
      p.position.xz = p.position.xz - gravityPoint.xz;
      p.position.xz = p.position.xz * (ease(t)+1) * 1.2;
      p.position.xz = p.position.xz + gravityPoint.xz;
    }
    gravityPoint.y = pManager.getParticles.map!(a => a.position.y).sum / pManager.getParticles.length;
    //apply to collisionSphere
    collisionSphere.Position = gravityPoint;
//    collisionSphere.setRadius(dodgeRate());

    colManager.exec();

  }

  private void getVertices(vec3[] vertices) {
    foreach (i, ref p; pManager.getParticles) {
      vertices[i] = p.position;
    }
  }

  private void onCollision(std.container.Array!CollisionInfo collisionInfo) {
    foreach (ref info; collisionInfo) {
      pairs ~= ContactPair(info, this);
    }
  }
  
  private float dodgeRate() {
    return dodgeCount;
  }

  private float dodgeTransform(float angle, float t) {
    enum alpha = 0.999;
    enum beta = 2;
    auto dAngle = (angle - PI * t^^2 + PI * 0.2).abs;
    if (dAngle > 2 * PI) dAngle -= 2 * PI;
    return 1 - t * (1-t) * 4 * alpha * exp(-dAngle^^2 * beta); 
  }

  package vec3 support(vec3 v) {
    return gravityPoint + v * MAX_dodge_RATE;
  }

  package vec3 getVelocity(vec3 p) {
    return linearVelocity + cross(angularVelocity, p - gravityPoint);
  }
}
