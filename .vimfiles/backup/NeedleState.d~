module player.needle.NeedleState;

import std.algorithm;
import std.container;
import collision;
import player.elastic;
import player.Input;
import player.Player;
import player.needle.NeedleSphere;
import player.PlayerState;
import player.Particle;
import player.PlayerDrawer;
import player.ParticleManager;
import player.PlayerCollisionManager;
import sbylib.math;
import sbylib.physics3d;

static import sbylib.physics3d.Narrow;

class NeedleState : PlayerState {

  private Player player;
  private NeedleSphere needleSphere;

  this(Player player, PlayerDrawer drawer, ParticleManager pManager, PlayerCollisionManager colManager) {
    this.player = player;
    this.needleSphere = new NeedleSphere(this, drawer, pManager, colManager, player.getShape);
  }

  override void init() {
    needleSphere.init();
  }

  override PlayerState step() {
    if (needleSphere.needleCount == 0) {
      needleSphere.end();
      return player.createState!("Elastic");
    }
    return this;
  }

  override bool setCollisionInfo(CollisionObject thisObj, CollisionObject obj, ref Array!CollisionInfo myInfo, ref Array!CollisionInfo objInfo) {
    vec3 pushVec;
    vec3[] collisionPoints;
    return castSwitch !(
        (Tripolygon tri) {
          if(sbylib.physics3d.Narrow.EPA(thisObj.shape, tri.shape, pushVec, collisionPoints) == false) return false;
          foreach (point; collisionPoints) {
            myInfo ~= CollisionInfo();
            with(myInfo.back) {
              object = obj;
              distance = pushVec.length;
              normal = pushVec / distance;
              vertex = point;
            }
            objInfo ~= CollisionInfo();
            with(objInfo.back) {
              object = thisObj;
              distance = pushVec.length;
              normal = pushVec / distance;
              vertex = point;
            }
          }
          return true;
        },
        (CollisionCapsule capsuleObj) {
          auto sphere = cast(PhysicalSphere)thisObj.shape;
          auto capsule = cast(PhysicalCapsule)capsuleObj.shape;
          if (sbylib.physics3d.Narrow.collisionSphereCapsule(sphere, capsule, pushVec) == false) return false;
          pushVec = -pushVec;
          auto point = needleSphere.support(pushVec);
          myInfo ~= CollisionInfo();
          with(myInfo.back) {
           object = obj;
           distance = pushVec.length;
           normal = pushVec / distance;
           vertex = point;
          }
          objInfo ~= CollisionInfo();
          with(objInfo.back) {
            object = thisObj;
            distance = pushVec.length;
            normal = pushVec / distance;
            vertex = point;
          }
          return true;
        },
        (CollisionObject colObj) {
          return false;
        }
    )(obj);
    return false;
  }
}
