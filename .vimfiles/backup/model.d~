module model.model;

import model.imports;
import collision;
import sbylib.entity.Drawable;
import sbylib.physics3d;
import std.math;

class Model : Drawable {

  private:
    package mat4 _matrix;
    mat4 defaultMatrix;
    vec3 defaultTranslate;
    bool matrixInitFlag = false;
    Mesh[] _meshes;
    CollisionObject[] _collisionObjects;

  public:
    // matrix は座標に対するアフィン変換用
    this(string path, ShaderProgram sp) {
      this(path, mat4.identity, sp);
    }

    this(string path, mat4 matrix, ShaderProgram sp) {
      this(path, matrix, null, sp);
    }

    this(string path, Material m) {
      this(path, mat4.identity, m);
    }

    this(string path, mat4 matrix = mat4.identity, Material m = null, ShaderProgram sp = null,
        void delegate(Mesh) manip = null) {
      _matrix = matrix;
      load(path);
      if (manip) _meshes.each!(m => manip(m));
      if (m is null) {
        m = new Material;
        m.withMaterial = (custom, rc, u) {
          rc.defaulting();
          rc.cullFace(false);
          u();
        };
        sp = getDefaultShaderProgram();
      }
      setCustomObject(m, sp);
    }

    override bool draw() {
      _meshes.each!(m => m.draw);
      return true;
    }

    vec3 getMin() {
      vec3 result = vec3(float.infinity);
      foreach(i; 0.._meshes.length) {
        result.x = min(result.x, _meshes[i].vertices.map!(v=>(_matrix*v).x).array.reduce!min);
        result.y = min(result.y, _meshes[i].vertices.map!(v=>(_matrix*v).y).array.reduce!min);
        result.z = min(result.z, _meshes[i].vertices.map!(v=>(_matrix*v).z).array.reduce!min);
      }
      return result;
    }

    vec3 getMax() {
      vec3 result = vec3(-float.infinity);
      foreach(i; 0.._meshes.length) {
        result.x = max(result.x, _meshes[i].vertices.map!(v=>(_matrix*v).x).array.reduce!max);
        result.y = max(result.y, _meshes[i].vertices.map!(v=>(_matrix*v).y).array.reduce!max);
        result.z = max(result.z, _meshes[i].vertices.map!(v=>(_matrix*v).z).array.reduce!max);
      }
      return result;
    }

    mat4 getMatrix() @nogc {
      return _matrix;
    }

    void setMatrix(mat4 matrix) @nogc {
      _matrix = matrix;
    }

    void multMatrix(mat4 matrix) @nogc {
      setMatrix(matrix * _matrix);
    }

    void setTexture(TextureObject texture) {
      _meshes.each!((Mesh m) {
          m.setTexture(texture);
          });
    }

    RigidBody3D createBox(PhysicsWorld3D world) {
      vec3[] vertices;
      foreach (mesh; _meshes) {
        foreach (ref v; mesh.vertices) {
          vertices ~= (_matrix * v).xyz;
        }
      }
      auto base = mostDispersionBasis(vertices);
      vec3 scale;
      vec3 center = vec3(0);
      foreach (i; 0..3) {
        float minT = 114514191981.0f, maxT = -114514191981.0f;
        foreach (v; vertices) {
          auto t = v.dot(base[i]);
          minT = min(minT, t);
          maxT = max(maxT, t);
        }
        scale[i] = (maxT - minT) / 2;
        center += (maxT + minT) / 2 * base[i];
      }

      auto box = world.createBox(RigidBody3D.Type.Dynamic, scale);
      box.shape.Position = center;
      box.shape.Orientation = mat4.replacement(base[0], base[1], base[2]).toMatrix3.toQuaternion;
      return box;
    }

    CollisionCapsule createCapsule(void delegate(Array!CollisionInfo) listener) {
      vec3[] vertices;
      foreach (mesh; _meshes) {
        foreach (ref v; mesh.vertices) {
          vertices ~= (_matrix * v).xyz;
        }
      }
      auto base = mostDispersionBasis(vertices);
      auto lengthList = base.map!(a => vertices.map!(b => a.dot(b)).reduce!((b,c) => b < c ? c : b) - vertices.map!(b => a.dot(b)).reduce!((b,c) => b < c ? b : c)).array;
      auto longest = lengthList.zip(base).reduce!((a,b) => a[0] < b[0] ? b : a)[1];
      float radius = 0;
      auto center = vertices.sum / vertices.length;
      foreach (ref v; vertices) {
        radius = max(radius, cross(v.xyz - center, longest).length);
      }
      float minT = float.infinity;
      float maxT = -float.infinity;
      foreach (ref v; vertices) {
        auto vec = center - v.xyz;
        float[] answer = solveQuadraticEquation(1, 2 * dot(longest, vec), vec.lengthSq - radius^^2);
        assert(answer);
        auto t = answer.reduce!((a,b) => a.abs < b.abs ? a : b);
        minT = min(t, minT);
        maxT = max(t, maxT);
      }
      return new CollisionCapsule(center + longest * minT, center + longest * maxT, radius, listener);
    }

    // 衝突オブジェクトの追加
    enum CollisionType {
      Map, Capsule
    }
    void addCollisionObject(Octree octree, CollisionType type, void delegate(Array!CollisionInfo) listener = null) {
      final switch(type) {
        case CollisionType.Map: 
          foreach(mesh; _meshes) {
            for(auto i=0; i<mesh.indices.length; i+=3) {
              uint[] ind = mesh.indices[i..i+3];
              CollisionObject object = new Tripolygon(
                  ind.map!(e => _matrix*mesh.vertices[e]).array,
                  _matrix*vec4(mesh.normals[ind[0]].x, mesh.normals[ind[0]].y, mesh.normals[ind[0]].z, 0.0)
                  );
              object.isStatic = true;
              object.setOctree(octree);
              object.addToOctree();
              if (listener !is null) object.listener = listener;
              object.userData = cast(void*)this;
              _collisionObjects ~= object;
            }
          }
          break;
        case CollisionType.Capsule: 
          auto capsule = createCapsule(listener);
          //capsule.setOctree(octree);
          //capsule.addToOctree();
          capsule.userData = cast(void*)this;
          _collisionObjects ~= capsule;
          break;
      }
    }

    // 衝突オブジェクトのアップデート
    void update() {
      _collisionObjects.each!(obj => obj.update());
    }
    //物理空間に登録
    void addToPhysicsWorld(PhysicsWorld3D world) {
      import sbylib;
      assert(_collisionObjects.length == 1, "the number of collisionObject is " ~ to!string(_collisionObjects.length));
      auto s = _matrix.getScale;
      auto t = _matrix.getTranslation;
      auto scale = mat4.scale(s);
      auto ori = (mat4.translate(-t) * _matrix * mat4.scale(1 / s));
      foreach (ref obj; _collisionObjects) {
        auto box = createBox(world);
        world.add(box);
        import sbylib;
        auto translate = mat4.translate(t - box.shape.Position);
        EntityManager.getInstance.add({
            _matrix = scale * mat4.translate(box.shape.Position) * box.shape.Orientation.toMatrix4 * translate * ori;
            return true;
            }, 60);
      }
    }

  private:
    void load(string path) {
      ModelLoader loader = new ModelLoader(path);
      _meshes.length = loader.getMeshes.length;
      foreach(i; 0.._meshes.length) {
        _meshes[i] = new Mesh(loader.getMeshes[i]);
      }
    }

    void setCustomObject(Material m, ShaderProgram shader) {
      _meshes.each!(mesh => mesh.initCustomObject(m, shader, _matrix));
    }

    ShaderProgram getDefaultShaderProgram() {
      return new ShaderProgram(
          "#version 330
      in vec4 mVertex;
      in vec2 mTexcoord;
      uniform mat4 mWorld;
      uniform mat4 mViewProj;
      out vec2 tc;

      void main() {
      gl_Position = mViewProj * mWorld * mVertex;
      tc = mTexcoord;
      }
      ", "#version 330
      uniform sampler2D mTexture;
      in vec2 tc;
      out vec4 FragColor;
      void main() {
      FragColor = texture(mTexture, tc);
      }
      ",
      ShaderProgram.InputType.SourceCode
        );
    }
}
