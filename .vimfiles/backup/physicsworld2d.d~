module sbylib.physics2d.PhysicsWorld2D;

import sbylib;
import sbylib.physics2d.Contact;
import sbylib.physics2d.RigidBody2D;
import sbylib.physics2d.Narrow;

class PhysicsWorld2D {
package:
	float timeStep;
	vec2 gravity;
private:
	RigidBody2D[] bodies;
	uint solveIteration;

	RigidBody2D[2][] pairs;
	Contact[] contacts;

	//bodiesからpairsを作る
	void broad() {
		pairs = null;
		foreach (i; 0..bodies.length) {
			foreach (j; i+1..bodies.length) {
				if (bodies[i].broadCollision(bodies[j])) {
					RigidBody2D[2] pair;
					pair[0]= bodies[i];
					pair[1] = bodies[j];
					pairs ~= pair;
				}
			}
		}
	}

	//pairsからcontactsを作る
	void narrow() {
		contacts = null;
		vec2 pushVec;
		vec2[] collisionPoints;
		foreach (pair; pairs) {
			if (EPA(pair[0], pair[1], pushVec, collisionPoints)) {
				foreach (c; collisionPoints) {
					contacts ~= Contact(pushVec, c, pair[0], pair[1]);
				}
			}
		}
	}

	//contactsを用いて拘束条件を解く
	void solve() {
		foreach (k; 0..solveIteration) {
			foreach (ref c; contacts) {
				//AB間の相対速度を計算
				auto vel = c.a.getVelocity(c.pos) - c.b.getVelocity(c.pos);

				//速度の法線方向成分を計算
				auto velN = dot(vel, c.normal);
				//A,Bの重心から衝突点までの相対位置
				auto ra = c.pos - c.a.pos;
				auto rb = c.pos - c.b.pos;
				//法線方向に既に離れていたらもういい
				if (velN > 0) continue;
				//法線方向の速度が0になるような撃力の大きさを計算
				auto impact =
					- velN 
					/ (c.a.massInv + c.b.massInv
					   + dot(c.a.inertiaInv * cross(cross(vec3(ra, 0), vec3(c.normal, 0)), vec3(ra,0))
							 +c.b.inertiaInv * cross(cross(vec3(rb, 0), vec3(c.normal, 0)), vec3(rb,0)), vec3(c.normal, 0)));
				//反発係数を考慮してちょっと大きくする
				impact *= 1 + c.restitution;
				//貫通深度を考慮してちょっと大きくする
				impact += c.penetration * 3;

				//法線方向に対して負の撃力になるようなら0で止まるように修正する
				if (dot(c.normal, c.totalImpact + impact * c.normal) < 0) {
					impact = -dot(c.normal, c.totalImpact);
				}
				vec2 normalImpact = impact * c.normal;
				//法線方向に叩く
				c.a.lVel += normalImpact * c.a.massInv;
				c.a.aVel += cross(vec3(ra, 0), vec3(normalImpact, 0)).z * c.a.inertiaInv;
				c.b.lVel -= impact * c.normal * c.b.massInv;
				c.b.aVel -= cross(vec3(rb, 0), vec3(normalImpact, 0)).z * c.b.inertiaInv;
				c.totalImpact += normalImpact;

				//衝突面に平行な方向を計算
				auto t = c.normal.yx; t.x = -t.x;
				//t方向に速度が0になるような撃力の大きさを計算
				impact = - dot(vel, t) 
					/ (c.a.massInv + c.b.massInv 
					   + dot(c.a.inertiaInv * cross(cross(vec3(ra, 0), vec3(t, 0)), vec3(ra,0))
							 +c.b.inertiaInv * cross(cross(vec3(rb, 0), vec3(t, 0)), vec3(rb,0)), vec3(t, 0)));
				//t方向に殴る
				vec2 parallelImpact = impact * t;
				//摩擦の限界値をつける
				if (parallelImpact.length > normalImpact.length * c.friction) {
					parallelImpact *= normalImpact.length / parallelImpact.length;
				}
				c.a.lVel += parallelImpact * c.a.massInv;
				c.a.aVel += cross(vec3(ra, 0), vec3(parallelImpact, 0)).z * c.a.inertiaInv;			
				c.b.lVel -= parallelImpact * c.b.massInv;
				c.b.aVel -= cross(vec3(rb, 0), vec3(parallelImpact, 0)).z * c.b.inertiaInv;
				c.totalImpact += parallelImpact;
			}
		}
	}

public:
	this(float timeStep, vec2 gravity, uint solveIteration) {
		this.timeStep = timeStep;
		this.gravity = gravity;
		this.solveIteration = solveIteration;
	}

	void testWorld() {
		RigidBody2D ground = new RigidBody2D([
			vec2(0, 200),
			vec2(600, 200),
			vec2(600, 300),
			vec2(0,300)
		], RigidBody2D.Type.Static);
		with (ground) {
			pos = vec2(SbyWorld.currentWindow.width/2, 150);
		}
		add(ground);
		foreach (k; 0..23) {
			import std.random;
			uint len = uniform(3, 10);
			vec2[] vertex;
			foreach (i; 0..len) {
				auto r = 40 + uniform(-10, 10
									  );
				auto t = 2 * PI * i / len;
				vertex ~= vec2(cos(t) * r, sin(t) * r);
			}
			RigidBody2D body1 = new RigidBody2D(vertex, RigidBody2D.Type.Dynamic);
			with (body1) {
				import std.random;
				pos = vec2(SbyWorld.currentWindow.width/2 + uniform(-100, 100) * 2, 500 + uniform(-100, 100));
				angle = uniform(0, 2 * PI);
			}
			add(body1);
		}
	}

	void add(RigidBody2D r) {
		bodies ~= r;
	}

	void step() {
		bodies.each!(a => a.step(this));
		broad();
		narrow();
		solve();
	}

	void draw() {
		bodies.each!(a => a.draw);
	}
}