module player.needle.NeedleSphere;

import std.container;
import collision;
import player;
import player.Constant;
import player.Input;
import player.PlayerCollisionManager;
import player.PlayerDrawer;
import player.ParticleManager;
import player.PlayerShape;
import player.needle.NeedleState;
import player.needle.ContactPair;
import sbylib;
import player.elastic;

class NeedleSphere {

  private enum MAX_NEEDLE_RATE = 2;
  private enum MIN_NEEDLE_RATE = 0.7f;

  private NeedleState needleState;
  private ParticleManager pManager;
  private PlayerCollisionManager colManager;
  private PlayerShape shape;
  private PlayerDrawer drawer;
  private PhysicalSphere collisionSphere;

  package vec3 gravityPoint;
  package quat orientation;
  package vec3 linearVelocity;
  package vec3 angularVelocity;
  private vec3[] rPos;
  package flim needleCount;
  private Array!ContactPair pairs;

  this(NeedleState needleState, PlayerDrawer drawer, ParticleManager pManager, PlayerCollisionManager colManager, PlayerShape shape){
    this.needleState = needleState;
    this.pManager = pManager;
    this.colManager = colManager;
    this.shape = shape;
    this.drawer = drawer;

    this.collisionSphere = new PhysicalSphere(1);
    this.needleCount = flim(0,0,1);
  }

  void init() {
    shape.step = &step;
    drawer.nextVertices = &getVertices;
    this.gravityPoint = pManager.getParticles.map!(p => p.position).sum / pManager.getParticles.length;
    this.orientation = quat(0,0,0,1);
    this.linearVelocity = pManager.getParticles.map!(p => p.velocity).sum / pManager.getParticles.length;
    this.angularVelocity = -linearVelocity.cross(vec3(0,1,0)).normalize * linearVelocity.length;
    rPos.length = pManager.getParticles.length;
    foreach (i, p; pManager.getParticles) {
      rPos[i] = p.position - gravityPoint;
      rPos[i] = rPos[i].normalize;
    }
    colManager.setCollisionShape(collisionSphere);
    colManager.setUserData(cast(void*)this);
    colManager.setListener(&onCollision);
  }

  void end() {
    foreach (p; pManager.getParticles) {
      p.velocity = getVelocity(p.position);
      p.force = p.extForce = vec3(0);
    }
  }

  private void step() {
    if (needleButton()) needleCount += 0.1f;
    else needleCount -= 0.03f;
    //needle
    foreach (i, p; pManager.getParticles) {
      rPos[i] = rPos[i].normalize * needleRate(p.isStinger);
    }
    //gravity
    linearVelocity += vec3(0,-1,0) * 0.1f * gravity * timeStep;
    //collision response
    foreach (k; 0..5) {
      foreach (ref pair; pairs)
        pair.solve;
    }
    pairs.clear();
    //teikou
    linearVelocity *= 0.99f;
    //integral
    gravityPoint += linearVelocity * timeStep;
    orientation = quat.createAxisAngle(angularVelocity * timeStep) * orientation;
    //apply to particle
    foreach (i, p; pManager.getParticles) {
      p.position = rotate(rPos[i], orientation) + gravityPoint;
    }
    //apply to collisionSphere
    collisionSphere.Position = gravityPoint;
    collisionSphere.setRadius(needleRate(true));

    colManager.exec();

  }

  private void getVertices(vec3[] vertices) {
    foreach (i, ref p; pManager.getParticles) {
      vertices[i] = p.position;
    }
  }

  private void onCollision(std.container.Array!CollisionInfo collisionInfo) {
    foreach (ref info; collisionInfo) {
      pairs ~= ContactPair(info, this);
    }
  }
  
  private float needleRate(bool isNeedle) {
    float t = needleCount;
    float arrival = isNeedle ? MAX_NEEDLE_RATE : MIN_NEEDLE_RATE;
    return (1-t) + t * arrival;
  }

  package vec3 support(vec3 v) {
    return gravityPoint + v * MAX_NEEDLE_RATE;
  }

  package vec3 getVelocity(vec3 p) {
    return linearVelocity + cross(angularVelocity, p - gravityPoint);
  }
}
