module enemy.TestEnemy;

import enemy;
import sbylib;
import collision.collisionObject.capsule;
import player;

class TestEnemy : GameAI{

  class Vertex {
    vec3 pos;
    Edge[] edges;
    Face[] faces;
    uint id;
    uint order;
    vec3 rPos; //orderでわけられた点群の重心に対する相対位置。
    vec3 vel; //速度
    alias pos this;

    this(vec3 p, uint id) { this.pos = p; this.id = id; this.vel = vec3(0);}

    Vertex[] nexts() {
      Vertex[] result;
      foreach (e; edges) {
        if (e.vertices[0] is this) result ~= e.vertices[1];
        else if (e.vertices[1] is this) result ~= e.vertices[0];
        else assert(false);
      }
      return result;
    }
  }

  class Edge {
    Vertex[2] vertices;
    Face[2] faces;
  }

  class Face {
    Vertex[] vertices;
    Edge[] edges;
    vec3 normal;
  }

  struct PositionInfo {
    vec3 pos;
    vec3 dir;
    vec3 up;
  }

  private CustomObject custom;
  private float time = 0;
  private Vertex[] vertexList;
  private Edge[] edgeList;
  private Face[] faceList;
  private float[] vertexArray;
  private vec3 vel;
  private PositionInfo[] history;
  private Vertex[][] vertexOrderList;

  this() {

    //===============まず頂点をデフォルトのやつから拾ってくる=====================
    auto vertex = Box.getVertices;
    auto faceIndices = Box.getIndices;

    uint idSeed = 0;

    //===============頂点・辺・面を構成==========================
    //面情報の代入は最後でいい(面情報は再帰時に全破棄される)
    //辺情報も同様
    foreach (v; vertex) vertexList ~= new Vertex(v, idSeed++);        //頂点作成
    foreach (idx; faceIndices) {
      auto face = new Face;                              //面作成
      foreach (i; 0..idx.length) {
        face.vertices ~= vertexList[idx[i]];           //面<-頂点
      }
      faceList ~= face;
    }

    //====================分割==================
    enum recursionLevel = 3;
    //頂点情報を1面につき5つ追加, 面情報は破棄され、新たな面が4つ追加
    uint getID(uint a, uint b) {return a < b ? a + b * 114514 : b + a *	114514;}
    Vertex[uint] memo;
    foreach (k; 0..recursionLevel) {
      Face[] newFaceList;
      foreach (face; faceList) {
        Vertex[4] newVertices;
        foreach (i; 0..4) {
          auto id = getID(face.vertices[i].id, face.vertices[(i+1)%$].id);
          if ((id in memo) is null) {
            newVertices[i] = new Vertex((face.vertices[i] + face.vertices[(i+1)%$])/2, idSeed++);
            vertexList ~= newVertices[i];
            memo[id] = newVertices[i];
          } else {
            newVertices[i] = memo[id];
          }
        }
        auto center = new Vertex(face.vertices.sum / face.vertices.length, idSeed++);
        vertexList ~= center;
        foreach (i; 0..4) {
          auto newFace = new Face;
          newFace.vertices = [face.vertices[i], newVertices[i], center, newVertices[(i+3)%$]];
          newFaceList ~= newFace;
        }
      }
      faceList = newFaceList;
    }
    //分割が終了。辺情報の構成及び互いのリンクを構成
    //面->頂点　のみできている
    Edge[uint] memory;
    foreach (face; faceList) {                           
      foreach (i; 0..face.vertices.length) {
        face.vertices[i].faces ~= face;                    //頂点<-面
        auto id = getID(face.vertices[i].id, face.vertices[(i+1)%$].id);
        if (id in memory) {
          auto edge = memory[id];
          assert(edge.faces[1] is null);
          edge.faces[1] = face;                          //辺<-面2
          face.edges ~= edge;                            //面<-辺
        } else {
          auto edge = new Edge;                          //辺作成
          edge.vertices[0] = face.vertices[i];           //辺<-頂点1
          edge.vertices[1] = face.vertices[(i+1)%$];     //辺<-頂点2
          face.vertices[i].edges ~= edge;                //頂点<-辺
          face.vertices[(i+1)%$].edges ~= edge;          //頂点<-辺
          edge.faces[0] = face;                          //辺<-面1
          face.edges ~= edge;                            //面<-辺
          edgeList ~= edge;
          memory[id] = edge;
        }
      }
    }
    //================法線=================
    foreach (f; faceList) {
      f.normal = cross(f.vertices[2] - f.vertices[1], f.vertices[0] - f.vertices[1]).normalize;
    }

    //=======番号振り===========
    uint vertexNum = 2^^recursionLevel + 1;
    float unitSize = 2.0f / (vertexNum-1);
    vec3i dir = vec3i(0,0,1);
    foreach (v; vertexList) {
      v.order = cast(uint)((dot(dir, v.pos) + 1) / unitSize);
      if (vertexOrderList.length <= v.order) vertexOrderList.length = v.order+1;
      vertexOrderList[v.order] ~= v;
    }
    //=============相対位置計算===========(n = vec3(0,0,1))
    foreach (vol; vertexOrderList) {
      auto g = vol.sum / vol.length;
      vol.each!(v => v.rPos = v.pos - g);
    }

    vertexArray = new float[vertexList.length * 3];

    uint[] indices;
    foreach (face; faceList) {
      foreach (i; 0..face.vertices.length - 2) {
        indices ~= face.vertices[0].id;
        indices ~= face.vertices[i+1].id;
        indices ~= face.vertices[i+2].id;
      }
    }

    custom = new CustomObject(new Material, ShaderStore.getShader("NormalGenerate"), Prim.Triangle);
    custom.beginMesh;
    custom.addAttribute!(3, "mVertex")(getVertexArray, GpuSendFrequency.Stream);
    custom.setIndex(indices, GpuSendFrequency.Static);
    custom.setUniformMatrix!(4, "mWorld")(mat4.identity.array);
    custom.addDynamicUniformMatrix!(4, "mViewProj")({return SbyWorld.currentCamera.getViewProjectionMatrix.array;});
    custom.endMesh;

    pos = vec3(0);
    vel = vec3(0.4, 0, 0);
    history.length = vertexOrderList.length * 5;
    history[] = PositionInfo(getPos, vel, vec3(0,1,0));
    PlayerAnnouncer.getInstance.addListener((info) {
        vel = info.pos - getPos;
        });
  }

  override bool step() {
    time++;
    enum timeStep = 0.1;
    pos = getPos + vel * timeStep;

    foreach (i; 0..history.length-1) {
      history[i] = history[i+1];
    }
    auto dir = vel.normalize;
    vec3 up;
    //upがdirと垂直な上っぽい向きになるようにうまいことアレ
    {
      auto t = sqrt(dir.y ^^2 / (dir.xz.lengthSq * (dir.y^^2 + 1)));
      if (dir.y > 0) t = -t;
      auto s = -t * dir.xz.lengthSq / dir.y;
      up.xz = dir.xz * t;
      up.y = s;
      assert(s >= 0);
      assert(up.length < 1.1);
      assert(dir.length < 1.1);
      assert(dot(up, dir) < 0.114514);
    }

    history[$-1] = PositionInfo(getPos, dir, up);


    foreach (i; 0..vertexOrderList.length) {
      auto his = history[i*5];
      mat4 transform = mat4.translate(his.pos) * mat4.replacement(cross(his.up, his.dir), his.up, his.dir);
      vertexOrderList[i].each!((v) {
          vec3 arrival = (transform * vec4(v.rPos,1)).xyz;
          vec3 dir = arrival - v.pos;
          auto dist = dir.length;
          dir /= dist;

          enum k = 3;
          enum c = 0.1;
          v.vel += dir * timeStep;
          v.vel *= 0.9;
          v.pos += v.vel * timeStep;
          v.pos = arrival;
          });
    }

    custom.update("mVertex", getVertexArray);
    return true;
  }

  override bool draw() {
    custom.draw;
    return true;
  }

  private float[] getVertexArray() {
    foreach (i, v; vertexList) vertexArray[i*3..i*3+3] = v.array;
    return vertexArray;
  }

  override string toString() {
    return "TestEnemy";
  }
}
