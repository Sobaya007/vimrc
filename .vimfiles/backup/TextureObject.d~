module sbylib.gl.TextureObject;

import sbylib;
import derelict.opengl3.gl;
import derelict.opengl3.gl3;

class TextureObject {
	import derelict.freeimage.freeimage;

	immutable uint texID;
	private int _width, _height;
	ImageType type;
	bool loaded = false;

	static this() {
		DerelictFI.load();
	}

	/*
	@params:
	filename = 読み込む画像の名前
	*/
	// filenameを受け取って、幅、高さ、GLtexIDを入手すればおｋ
	this(string filename){
		writeln("Target : " ~ filename);
		auto type = FreeImage_GetFileType(filename.toStringz,0);
		if(type == -1){
			writeln("Error : file not found");
			writeln();
			return;
		}
		FIBITMAP* origin = FreeImage_Load(type,filename.toStringz);
		if(!origin){
			writeln("Error : cannot load file");
			writeln();
			return;
		}
		FIBITMAP* bitmap = FreeImage_ConvertTo32Bits(origin);
		_width = FreeImage_GetWidth(bitmap);
		_height = FreeImage_GetHeight(bitmap);
		writeln("Size (" ~ to!string(_width) ~ "x" ~ to!string(_height) ~ ")");
		uint textureID;
		glGenTextures(1,&textureID);
		texID = textureID;
		glBindTexture(GL_TEXTURE_2D, textureID);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, _width, _height,
				    0, GL_BGRA, GL_UNSIGNED_BYTE, FreeImage_GetBits(bitmap));
		FreeImage_Unload(bitmap);
		FreeImage_Unload(origin);
		writeln("successfully loaded.");
		writeln();

		loaded = true;
	}

	/*
	@params:
	_width = テクスチャの幅
	_height = テクスチャの高さ
	texMode = テクスチャの種類(GL_RBGなど)
	depthUse = テクスチャに深度バッファを使うか否か
	*/
	this(int _width, int _height, ImageType type) {
		// レンダリングしようとしているテクスチャ
		uint id;
		glGenTextures(1, &id);
		this.texID = id;

		bind();

		// OpnGLに空の画像を与える(最後が"0")
		glTexImage2D(GL_TEXTURE_2D, 0, type, _width, _height, 0, type, GL_UNSIGNED_BYTE, null);

		// フィルタリング
		setMagFilter(TexFilterType.Linear);
		setMinFilter(TexFilterType.Linear);
		setWrapS(TexWrapType.Repeat);
		setWrapT(TexWrapType.Repeat);

		this._width = _width;
		this._height = _height;
		this.type = type;

		unBind();


		loaded = true;
	}

	/*
	@params:
	buffer =　読み込むビットマップ情報
	*/
	this(ubyte* buffer, int _width, int _height) {
		uint texID;
		// Generate a new texture
		glGenTextures(1, &texID);

		// Bind the texture to a name
		glBindTexture(GL_TEXTURE_2D, texID);

		// Set texture clamping method
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

		// Set texture interpolation method to use linear interpolation (no MIPMAPS)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

		// Specify the texture specification
		glTexImage2D(
					 GL_TEXTURE_2D,
					 0,          // mipmap
					 GL_RGBA,
					 _width,          // _width
					 _height,          // _height
					 0,          // border
					 GL_RGBA,
					 GL_UNSIGNED_BYTE,
					 buffer
					 );

		this.texID = texID;
		this._width = _width;
		this._height = _height;

		loaded = true;

	}

	@property uint width() {
		return _width;
	}

	@property uint height() {
		return _height;
	}

	@property void width(uint w) {
		_width = w;
		bind();
		glTexImage2D(
							GL_TEXTURE_2D,
							0,          // mipmap
							GL_RGBA,
							_width,          // _width
							_height,          // _height
							0,          // border
							GL_RGBA,
							GL_UNSIGNED_BYTE,
							null
							);
		unBind();
	}

	@property void height(uint h) {
		_height = h;
		bind();
		glTexImage2D(
					 GL_TEXTURE_2D,
					 0,          // mipmap
					 GL_RGBA,
					 _width,          // _width
					 _height,          // _height
					 0,          // border
					 GL_RGBA,
					 GL_UNSIGNED_BYTE,
					 null
					 );
		unBind();
	}
	enum TexFilterType {Linear = GL_LINEAR, Nearest = GL_NEAREST}

	void setMagFilter(TexFilterType type) {
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, type);
	}

	void setMinFilter(TexFilterType type) {
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, type);
	}

	enum TexWrapType {
		Repeat = GL_REPEAT,
		Clamp = GL_CLAMP,
		ClampToEdge = GL_CLAMP_TO_EDGE,
		ClampToBorder = GL_CLAMP_TO_BORDER,
		MirroredRepeat = GL_MIRRORED_REPEAT
	}

	void setWrapS(TexWrapType type) {
		bind();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, type);
		unBind();
	}

	void setWrapT(TexWrapType type) {
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, type);
	}

	void bind() {
		glBindTexture(GL_TEXTURE_2D, texID);
	}

	void unBind() {
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	void write(void delegate() func) {
		static FrameBufferObject fbo;
		if (fbo is null) fbo = new FrameBufferObject;
		fbo.attachTextureAsColor(this);
		fbo.write(width, height, func);
	}

	alias texID this;
}