module sbylib.physics3d.PhysicsWorld3D;

import sbylib;
import sbylib.physics3d.Contact;
import sbylib.physics3d.Narrow;

class PhysicsWorld3D : Entity, Drawable{
package:
  float timeStep;
  vec3 gravity;
  private:
  RigidBody3D[] bodies;
  Joint[] joints;
  uint solveIteration;

  LimitedArray!(RigidBody3D[2], 1000) pairs = new LimitedArray!(RigidBody3D[2], 1000);
  LimitedArray!(Contact, 1000) contacts = new LimitedArray!(Contact, 1000);

  //bodiesからpairsを作る
  void broad() {
    pairs.clear;
    foreach (i; 0..bodies.length) {
      foreach (j; i+1..bodies.length) {
        if (bodies[i].type == bodies[j].type && bodies[i].type == RigidBody3D.Type.Static) continue;
        if (bodies[i].broadCollision(bodies[j])) {
          RigidBody3D[2] pair;
          pair[0]= bodies[i];
          pair[1] = bodies[j];
          pairs.add(pair);
        }
      }
    }
  }

  //pairsからcontactsを作る
  void narrow() {
    contacts.clear;
    vec3 pushVec;
    vec3[] collisionPoints;
    foreach (i; 0..pairs.length) {
      auto pair = pairs[i];
      if (EPA(pair[0].shape, pair[1].shape, pushVec, collisionPoints)) {
        if (pushVec.lengthSq == 0) continue;
        foreach (c; collisionPoints) {
          contacts.add(Contact(pushVec, c, pair[0], pair[1]));
        }
      }
    }
  }

  //contactsを用いて拘束条件を解く
  void solve() {
    foreach( ref c; joints) {
      c.prepareSolve;
    }
    import std.random;
    randomShuffle(contacts);
    randomShuffle(joints);
    foreach (k; 0..solveIteration) {
      foreach (ref c; contacts) {
        c.solve;
      }
      foreach( ref c; joints) {
        c.solve;
      }
    }
  }

  public:
  this() {
    this.timeStep = 1.0 / 60;
    this.gravity = vec3(0, -10, 0);
    this.solveIteration = 10;
  }

  void setTimeStep(float timeStep) {
    this.timeStep = timeStep;
  }

  void setGravity(vec3 gravity) {
    this.gravity = gravity;
  }

  void setSolveIteration(int it) {
    this.solveIteration = it;
  }

  RigidBody3D createBox(RigidBody3D.Type type, vec3 scale = vec3(1)) {
    auto v = Box.getVertices;
    v[] *= scale;
    return new RigidBody3D(new ConvexHull(v, Box.getIndices), type);
  }

  void testWorld() {

    import std.random;

    foreach (i; 0..30) {
      auto box = createBox(RigidBody3D.Type.Dynamic, vec3(2));
      with (box.shape) {
        Position = vec3(uniform(-3, 3.0), uniform(0, 10.0),uniform(-3,3.0)) * 10 + vec3(0,3,0);
        Orientation = quat.createAxisAngle(vec3(uniform(-1.0,1), uniform(-1.0, 1), uniform(-1.0, 1)) * uniform(0, PI));
      }
      add(box);
    }
    foreach (i; 0..30) {
      auto sphere = new RigidBody3D(new PhysicalSphere(1), RigidBody3D.Type.Dynamic);
      with (sphere.shape) {
        Position = vec3(uniform(-3, 3.0), uniform(0, 10.0),uniform(-3,3.0)) * 10 + vec3(0,3,0);
      }
      add(sphere);
    }

    auto capsule = new PhysicalCapsule(3, 1);
    capsule.Position = vec3(0, 10, 0);
    add(new RigidBody3D(capsule, RigidBody3D.Type.Dynamic));


    RigidBody3D ground = createBox(RigidBody3D.Type.Static, vec3(40, 1, 40));
    with (ground.shape) {
      Position = vec3(0,-10, 0);
    }
    add(ground);
  }

  void add(RigidBody3D r) {
    bodies ~= r;
    r.shape.update;
    r.shape.isRegistered = true;
  }

  void add(Joint c) {
    joints ~= c;
  }

  void remove(RigidBody3D r) {
    foreach (i; 0..bodies.length) {
      if (bodies[i] == r) {
        bodies = bodies[0..i] ~ bodies[i+1..$];
        break;
      }
    }
    r.shape.isRegistered = false;
  }

  override bool step() {
    bodies.each!(a => a.step(this));
    broad();
    narrow();
    solve();
    return true;
  }

  override bool draw() {
    bodies.each!(a => a.draw);
    return true;
  }

  override string toString() {
    return "PhysicsWorld3D";
  }
}
