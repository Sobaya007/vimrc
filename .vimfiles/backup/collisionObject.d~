module collision.collisionObject.collisionObject;

import collision.imports;
import sbylib;

class CollisionObject : Drawable {
  Cell cell; // 登録されている空間
  CollisionObject preObj; // 前のオブジェクト
  CollisionObject nextObj; // 後のオブジェクト

  bool isStatic = false; // これがtrue同士のオブジェクトとは衝突判定を行わない

  public Shape shape;

  protected:
  struct AABB {
    vec3 minimum, maximum;
  }
  AABB _aabb;
  CollisionObject[] _collidedObjects;
  bool _onOctree;
  Octree _octree;

  public:

  this(Shape shape) {
    this.shape = shape;
  }

  vec3 getMin() {
    return _aabb.minimum;
  }
  vec3 getMax() @nogc {
    return _aabb.maximum;
  }

  void update() in {
    assert(_octree !is null);
    assert(_onOctree);
  } body {
    // 8分木への再登録
    removeFromOctree();
    addToOctree();
  }

  override bool draw() {
    shape.draw;
    return true;
  }

  void* userData;
  void delegate(Array!CollisionInfo info) listener;
  Array!CollisionInfo collisionInfo;

  void addToOctree() in {
    assert(_octree !is null);
  } body {
    _octree.add(this);
    _onOctree = true;
  }

  void removeFromOctree() in {
    assert(_octree !is null);
  } body {
    _octree.remove(this);
    _onOctree = false;
  }

  void setOctree(Octree octree) {
    _octree = octree;
  }

  void clearInfo() @nogc {
    collisionInfo.clear;
  }
<<<<<<< HEAD

  //@return : whether this and obj are collising.
  bool setCollisionInfo(CollisionObject obj, ref Array!CollisionInfo myInfo, ref Array!CollisionInfo objInfo) 
  out(result) {
    debug {
      assert(result == false || this.getOrder < obj.getOrder);
    }
  }
  body {
    return false;
  }

  abstract uint getOrder();
=======
>>>>>>> crystal_fix

}
