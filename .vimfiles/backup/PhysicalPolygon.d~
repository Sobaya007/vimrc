module sbylib.physics3d.PhysicalPolygon;

import sbylib;
import sbylib.physics3d.Shape;

class PhysicalPolygon : Shape {

  private:
    Face face0, face1;
  public:

    this(vec3[] vertex...) {
      this.face0 = new Face();
      this.face1 = new Face();
      auto normal = (vertex[1] - vertex[0]).cross(vertex[2] - vertex[1]).normalize;
      foreach (p; vertex) {
        auto v = new Vertex(p);
        v.worldPosition = v.position;
        v.faces ~= face0;
        face0.vertices ~= v;

        v = new Vertex(p);
        v.worldPosition = v.position;
        v.faces ~= face1;
        face1.vertices ~= v;
      }
      face0.normal = normal;
      face1.normal =-normal;
      super();
    }

override:
    float computeVolume() {
      return 0;
    }
    mat3 computeInertiaTensor() {
      return mat3.scale(vec3(1)); //適当。許せ。
    }
    CustomObject createCustomObject() {
      uint[] idx;
      foreach (i; 2..face0.vertices.length) {
        idx ~= to!(uint[])([0, i-1, i]);
      }
      CustomObject custom = new CustomObject(new Material, ShaderStore.getShader("NormalGenerate"), Prim.Triangle);
      custom.beginMesh;
      custom.addAttribute!(3, "mVertex")(face0.vertices.map!(a => a.array).reduce!((a,b) => a ~ b).array, GpuSendFrequency.Static);
      custom.setIndex(idx, GpuSendFrequency.Static);
      custom.setUniformMatrix!(4, "mWorld")(mat4.identity.array);
      custom.addDynamicUniformMatrix!(4, "mViewProj")({return SbyWorld.currentCamera.getViewProjectionMatrix.array;});
      custom.endMesh;
      return custom;
    }
    vec3 getMaxPoint() {
      return vec3(
          face0.vertices.map!(a => a.x).reduce!((a,b) => a > b ? a : b),
          face0.vertices.map!(a => a.y).reduce!((a,b) => a > b ? a : b),
          face0.vertices.map!(a => a.z).reduce!((a,b) => a > b ? a : b)
          );
    }
    vec3 getMinPoint() {
      return vec3(
          face0.vertices.map!(a => a.x).reduce!((a,b) => a < b ? a : b),
          face0.vertices.map!(a => a.y).reduce!((a,b) => a < b ? a : b),
          face0.vertices.map!(a => a.z).reduce!((a,b) => a < b ? a : b)
          );
    }
    void updateCustomObject(CustomObject custom) {
      return;
    }
    vec3 support(vec3 d) {
      with (face0) {
        auto dotP = dot(vertices[0], d);
        vec3 result = vertices[0].position;
        foreach (i; 1..vertices.length) {
          result = dot(result, d) > dot(vertices[i], d) ? result : vertices[i];
        }
        enum depth = 0.8;
        result = 0 > -face0.normal.dot(d) ? result : result + face0.normal * depth;
        return result;
      }
    }
    Face supportFace(vec3 d) {
      return face0;
      return dot(d, face0.normal) > 0 ? face0 : face1;
    }
}
