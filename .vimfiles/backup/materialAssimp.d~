module model.modelloader.materialAssimp;
import model.imports;
class Material_Assimp {
private:
	vec4 _diffuse;
	vec4 _specular;
	vec4 _ambient;
	TextureObject _texture;
public:
	this(const aiMaterial* material, string scenePath) in {
		assert(material !is null);
	} body {
		aiColor4D color;
		// diffuse
		aiGetMaterialColor(material, AI_MATKEY_COLOR_DIFFUSE, 0, 0, &color);
		_diffuse = convertColor(color);
		// specular
		aiGetMaterialColor(material, AI_MATKEY_COLOR_SPECULAR, 0, 0, &color);
		_specular = convertColor(color);
		// ambient
		aiGetMaterialColor(material, AI_MATKEY_COLOR_AMBIENT, 0, 0, &color);
		_ambient = convertColor(color);
		//writeln("diffuse: ", _diffuse);
		//writeln("specular: ", _specular);
		//writeln("ambient: ", _ambient);
		// texture
		aiString aiPath;
		if (aiGetMaterialTexture(material, aiTextureType_DIFFUSE, 0, &aiPath, null, null, null, null, null) == aiReturn_SUCCESS) {
            string path = scenePath.replace("\\", "/").split("/")[0..$-1].reduce!((a, b) => a~"/"~b) ~ "/" ~ convertString(aiPath).replace("\\", "/").split("/")[$-1];
            writeln(convertString(aiPath));
			_texture = new TextureObject(SbyWorld.rootPath ~ path);
			if (_texture.loaded == false) 
				_texture = null;
		} else {
			_texture = null;
		}
	}

	vec4 diffuse() @nogc {
		return _diffuse;
	}

	vec4 specular() @nogc {
		return _specular;
	}

	vec4 ambient() @nogc {
		return _ambient;
	}

	TextureObject texture() @nogc {
		return _texture;
	}
private:
    vec4 convertColor(aiColor4D c) @nogc {
		return vec4(c.r, c.g, c.b, c.a);
	}
	string convertString(aiString s) {
		return s.data[0..s.length].idup;
	}
}