module sbylib.physics2d.RigidBody2D;


import sbylib;

/*
剛体を表すクラス
密度は一定とする
反発係数は0.5
摩擦係数は0.5
質量は、動く物体なら1,そうでないなら∞
形状は凸多角形とする(そうじゃないと死ぬ)
頂点情報は時計回り(逆でもいい)に整列しているとする
*/
class RigidBody2D {

	enum Type {Static, Dynamic} //動くものか否か

	vec2[] vertex; //もとの状態での頂点座標(原点は重心位置)
	vec2 pos; //重心位置
	vec2 lVel; //重心速度(linear velocity)
	float angle; //もとの状態からの回転量(反時計周りが正)
	float aVel; //回転速度(angular velocity)
	float restitution; //反発係数
	float friction; //摩擦係数
	float mass; //質量
	float inertia; //重心周りの慣性モーメント
	Type type;

	vec2[] worldVertex; //ワールド座標
	vec4 color = white;
	vec2 lower, upper; //AABB

	//本質ではない情報
	float massInv;
	float inertiaInv;

	this(vec2[] vertex, Type type) 
	in{
		assert(vertex.length > 0);
	}
	body{
		//各値を初期化
		this.pos = vec2(0);
		this.lVel = vec2(0);
		this.angle = 0;
		this.aVel = 0;
		this.restitution = 0.5;
		this.friction = 0.5;
		this.mass = type == Type.Dynamic ? 1 : float.infinity;
		this.type = type;
		this.vertex = vertex;

		//頂点座標の原点と重心を一致させる
		auto g = sum(vertex) / vertex.length;
		foreach (ref v; vertex) v -= g;

		//重心(原点)周りの慣性モーメントを求める
		this.inertia = 0;
		foreach (i; 0..vertex.length) {
			auto j = (i+1) % vertex.length;
			this.inertia += mass * (vertex[i].lengthSq + vertex[j].lengthSq + dot(vertex[i], vertex[j])) / 6 / vertex.length;
		}

		this.massInv = 1 / mass;
		this.inertiaInv = 1 / inertia;
	}

	void calculateWorldVertex() {
		//各頂点のワールド座標を計算
		worldVertex = [];
		float c = cos(angle), s = sin(angle);
		foreach (i, v; vertex) {
			worldVertex ~= vec2(c * v.x - s * v.y, s * v.x + c * v.y) + pos;
		}
		this.lower = vec2(float.infinity);
		this.upper = vec2(-float.infinity);
		foreach (ref v; worldVertex) {
			lower.x = min(lower.x, v.x);
			lower.y = min(lower.y, v.y);
			upper.x = max(upper.x, v.x);
			upper.y = max(upper.y, v.y);
		}
	}

	vec2 getVelocity(vec2 p) {
		return lVel + cross(vec3(0,0,aVel), vec3(p - pos, 0)).xy;
	}

	bool broadCollision(RigidBody2D r) {
		if (r.upper.x < lower.x) return false;
		if (r.upper.y < lower.y) return false;
		if (r.lower.x > upper.x) return false;
		if (r.lower.y > upper.y) return false;
		return true;
	}

	void draw() {
		foreach (i; 0..worldVertex.length) {
			auto j = (i+1) % worldVertex.length;
			drawLine(worldVertex[i], worldVertex[j], color);
			//writeln(worldVertex[i]);
		}
	}

	void step(PhysicsWorld2D world) {

		calculateWorldVertex();

		with (world) {
			if (type == Type.Dynamic) {

				//積分
				pos += lVel * timeStep;
				angle += aVel * timeStep;

				//重力
				lVel += gravity * timeStep;
				if (pos.y < -100) {
					pos = vec2(SbyWorld.currentWindow.width/2, SbyWorld.currentWindow.height + 100);
					lVel = vec2(0);
					aVel = 0;
				}
			}
		}
	}
}