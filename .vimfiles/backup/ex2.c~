#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <dirent.h>

#define MAX_ARGS 50
#define MAX_LEN 500
#define MAX_PROGRAM_NUM 10
#define MAX_HISTORY_NUM 200

#define ESC 27
#define BLOCK 91
#define UP 65
#define DOWN 66
#define RIGHT 67
#define LEFT 68
#define UP_KEY 128
#define DOWN_KEY 129
#define RIGHT_KEY 130
#define LEFT_KEY 131

char *onUpKey();
char *onDownKey();
void onTabKey(char*);
int getLine(char result[MAX_LEN]);
void chomp(char*);

void pipeN(char *programs[1024][MAX_PROGRAM_NUM],int programNum);

char history[MAX_LEN][MAX_HISTORY_NUM];
int historyNum = 0;
int currentHistory;
int bufferLength = 0;
struct termios io_buffer;

int main(void)
{

	int argc, n = 0;
	char input[MAX_LEN], *argv[MAX_ARGS], *cp;
	const char *delim = " \t\n"; /* コマンドのデリミタ(区切り文字) */

	/*termiosを設定
	 *エコーを切る
	 カノニカルモードを切る*/
	struct termios io_conf = {0};

	tcgetattr( fileno(stdin) , &io_conf );
	memcpy( &io_buffer , &io_conf , sizeof(struct termios) );
	io_conf.c_lflag &= ~( ECHO | ICANON );
	io_conf.c_cc[VMIN] = 1;
	io_conf.c_cc[VTIME] = 0;
	tcsetattr( fileno(stdin), TCSAFLUSH , &io_conf );

	while (1) {
		memset(input, '\0', sizeof(input));
		/* プロンプトの表示*/
			++n;
    printf("\033[33m");
    printf("\033[1m");
		printf("command[%d] ", n);
    printf("\033[0m");

		//1行取得
		//EOFで終了
		if (getLine(input)) {
			break;
		}

		//!キーによるinputの変更
		if (input[0] == '!') {
			if (input[1] == '!') {
        if (historyNum > 0)
				strcpy(input, history[historyNum-1]);
			} else {
				int pos = 1;
				int num = 0;
				int status = 0;
				while (input[pos]) {
					printf("%c\n", input[pos]);
					if (input[pos] < '0' || input[pos] > '9') {
						status = 1;
						break;
					}
					int n = input[pos] - '0';
					num *= 10;
					num += n;
					pos++;
				}
				if (status == 0 && num < MAX_HISTORY_NUM-1) {
					strcpy(input, history[num]);
				}
			}
			//変更内容を出力
			printf("%s\n", input);
		}

		//Historyを更新
		if (historyNum < MAX_HISTORY_NUM-1) {
			strcpy(history[historyNum++], input);
		} else {
			int i;
			for (i = 0; i < MAX_HISTORY_NUM; i++) {
				strcpy(history[i], history[i+1]);
			}
			strcpy(history[MAX_HISTORY_NUM-1], input);
		}
		currentHistory = historyNum;

		/* コマンド行を空白/タブで分割し，配列 argv[] に格納する */
		cp = input;
		for (argc = 0; argc < MAX_ARGS; argc++) {
			if ((argv[argc] = strtok(cp,delim)) == NULL)
				break;
			cp = NULL;
		}
		//exit, history, cdコマンド
		if (strcmp(input, "exit") == 0) {
			break;
		} else if (strcmp(input, "history") == 0) {
			int i;
      printf("\033[32m");
			for (i = 0; i < historyNum; i++) {
				printf("%5d %s\n", i, history[i]);
			}
      printf("\033[0m");
			continue;
		} else if (strcmp(argv[0], "cd") == 0) {
      if (chdir(argv[1]) == 0) {
        getcwd(input, sizeof(input));
        printf("%s\n", input);
      } else {
        printf("%s is not a directry\n", argv[1]);
      }
      continue;
    }

		//3.パイプ機能
		//「|」を探す
		char *programs[1024][MAX_PROGRAM_NUM];
		char *current;
		int idx = 0;
		int num = 0;
		int i;
		for (i = 0; i < MAX_ARGS; i++) {
			if (argv[i] == NULL) break;
			if (strcmp(argv[i], "|") == 0) {
				idx++;
				num = 0;
			} else {
				programs[idx][num++] = argv[i];
			}
		}
		//プログラム実行
		pipeN(programs, idx+1);

	}
	//termiosをデフォルトに戻す
	tcsetattr( fileno(stdin) , TCSAFLUSH , &io_buffer );
  //文字設定をデフォルトに戻す
  printf("\033[0m");
}

//1行取得する関数。
//通常終了時には0を、EOFが来たときには1を返す。
int getLine(char result[MAX_LEN]) {
	int count = 0;
	char key = 0;
	while (1) {
		key = fgetc(stdin);
		if (key == '\n') {
		  //改行文字で終了
      break;
    } else if (key == 4) {
      //EOFで終了
			printf("Goodbye!\n");
			return 1;
		} else if (count == 0 && key == ESC) {
      //ESCで制御文字モードへ
			count++;
			continue;
		} else if (count == 1 && key == BLOCK) {
      //[で制御文字続き
			count++;
			continue;
		} else if (count == 2) {
      //制御文字確定
			switch (key) {
				case UP:
					strcpy(result, onUpKey());
					break;
				case DOWN:
					strcpy(result, onDownKey());
					break;
				case RIGHT:
					break;
				case LEFT:
					break;
				default:
					break;
			}
			count = 0;
			continue;
		}else if (key == 127) {
      //BackSpaceで削除
			if (bufferLength > 0) {
				printf("\b \b");
				bufferLength--;
				result[bufferLength] = 0;
			}
		} else if (key == '\t') {
      //Tabで補完 
      onTabKey(result);
    } else {
      //その他
      //|と!に色付け
      if (key == '|' || key == '!')
        printf("\033[36m");
			printf("%c\033[0m", key);
			result[bufferLength++] = key;
    }
	}
	result[bufferLength] = 0;
	bufferLength = 0;
	printf("\n");
	return 0;
}

char *onUpKey() {
	if (currentHistory > 0) {
		currentHistory--;
	}
	int i;
	for (i = 0; i < bufferLength; i++)
		printf("\b");
	char *h = history[currentHistory];
	int len = strlen(h);
	printf("%s", h);

	int extra = bufferLength > len ? bufferLength - len : 0;
	for (i = 0; i < extra; i++)
		printf(" ");
	for (i = 0; i < extra; i++)
		printf("\b");


	bufferLength = len;
	return h;
}

char *onDownKey() {
	if (currentHistory < MAX_HISTORY_NUM - 1) {
		currentHistory++;
	}
	int i;
	for (i = 0; i < bufferLength; i++)
		printf("\b");
	char *h = history[currentHistory];
	int len = strlen(h);
	printf("%s", h);

	int extra = bufferLength > len ? bufferLength - len : 0;
	for (i = 0; i < extra; i++)
		printf(" ");
	for (i = 0; i < extra; i++)
		printf("\b");

	bufferLength = len;

	return h;
}

void onTabKey(char result[MAX_LEN]) {
  //カレントディレクトリのフォルダを全取得
  char dirName[MAX_LEN]; 
  getcwd(dirName, sizeof(dirName));
  struct dirent **nameList;
  int r = scandir(dirName, &nameList, NULL, NULL);
  if (r == -1) {
    printf("Scan Directry Failed.\n");
    return;
  }
  //resultを空白で区切る
  char resultCpy[MAX_LEN];
  strcpy(resultCpy, result);
  char *tmp = strtok(resultCpy, " ");
  char *last = tmp;
  int frontLength = 0;
  while(tmp) {
    frontLength += tmp - last;
    last = tmp;
    tmp = strtok(NULL, " ");
  }
  int lastLen = bufferLength - frontLength;
  if (last == NULL) return;
  //文字のマッチ
  int i;
  char *matchStr = NULL;
  for (i = 0; i < r; i++) {
    int j;
    int flag = 1;
    if (strlen(nameList[i]->d_name) < lastLen) continue;
    for (j = 0; j < lastLen; j++) {
      if (nameList[i]->d_name[j] != last[j]) {
        flag = 0;
        break;
      }
    }
    if (flag == 1) {
      if (matchStr == NULL) 
        matchStr = nameList[i]->d_name;
      else {
        //すでにマッチした文字列がある場合、最大公約数をとってくる
        int a = strlen(matchStr);
        int b = strlen(nameList[i]->d_name);
        int len = a < b ? a : b;
        for (j = 0; j < len; j++)
          if (matchStr[j] != nameList[i]->d_name[j])
            break;
        int k;
        for (k = j; k < strlen(matchStr); k++) matchStr[k] = 0;
      }
    }
  }
  if (matchStr == NULL) return;
  //バッファの更新
  strcpy(&result[frontLength], matchStr);
  for (i = 0; i < bufferLength; i++) printf("\b");
  int extra = strlen(result) - bufferLength;
  if (extra < 0) extra = 0;
  printf("%s", result);
  for (i = 0; i < extra; i++) printf(" ");
  for (i = 0; i < extra; i++) printf("\b");
  bufferLength = strlen(result);
}

void pipeN(char *programs[1024][MAX_PROGRAM_NUM],int programNum) {
	if (programNum == 1) {
		if (fork() == 0) {
			execvp(programs[0][0], programs[0]);
		}
		wait(NULL);
		return;
	}
	int fd[2];
	pipe(fd);
	if (fork() == 0) {
		close(fd[0]);
		dup2(fd[1], 1);
		execvp(programs[0][0], programs[0]);
	} else {
		wait(NULL);
		close(fd[1]);
		if (fork() == 0) {
			int i = 1;
			int fdCopy[2];
			fdCopy[0] = fd[0];
			fdCopy[1] = fd[1];
			while (i < programNum-1) {
				pipe(fd);
				if (fork() == 0) {
					close(fdCopy[0]);
					close(fd[1]);
					dup2(fd[0], 0);
					fdCopy[0] = fd[0];
					fdCopy[1] = fd[1];
				} else {
					close(fd[0]);
					dup2(fdCopy[0], 0);
					dup2(fd[1], 1);
					execvp(programs[i][0], programs[i]);
				}
				i++;
			}
			dup2(fdCopy[0], 0);
			execvp(programs[i][0], programs[i]);
		}
		wait(NULL);
	}
} 
