module model.mesh;

import model.imports;
import sbylib.gl.Constants;
static import sbylib.core.World;

class Mesh {

  private:
    int _id;
    static int _total;

    public {
      vec4[] _vertices;
      vec3[] _normals;
      vec2[] _texCoords;
      uint[] _indices;
    }

    // material
    int _materialIndex;
    vec4 _diffuse;
    vec4 _specular;
    vec4 _ambient;
    TextureObject _texture;
    package CustomObject _custom;

    package alias _custom this;

  public:
    this(Mesh_Assimp mesh) {
      _id = _total++;

      _vertices = mesh.vertices;
      _normals = mesh.normals;
      _texCoords = mesh.texCoords;
      _indices = mesh.indices.dup;
      _materialIndex = mesh.materialIndex;

      _materialIndex = mesh.materialIndex;
      _diffuse = mesh.material.diffuse;
      _specular = mesh.material.specular;
      _ambient = mesh.material.ambient;
      _texture = mesh.material.texture;
    }

    void initCustomObject(Material m, ShaderProgram shader, Mode model) {
      _custom = new CustomObject(m, shader, Prim.Triangle);
      _custom.beginMesh();
      _custom.addAttribute!(4, "mVertex")(vertices.map!(v => [v.x, v.y, v.z, v.w]).array.join, GpuSendFrequency.Static);
      _custom.addAttribute!(3, "mNormal")(normals.map!(n => [n.x, n.y, n.z]).array.join, GpuSendFrequency.Static);
      _custom.addAttribute!(2, "mTexcoord")(texCoords.map!(t => [t.x, t.y]).array.join, GpuSendFrequency.Static);
      _custom.setIndex(indices.reverse, GpuSendFrequency.Static);
      _custom.addDynamicUniformMatrix!(4, "mWorld")({return model.getMatrix.array;});
      _custom.addDynamicUniformMatrix!(4, "mViewProj")({return sbylib.core.World.SbyWorld.currentCamera.getViewProjectionMatrix().array;});
      _custom.addDynamicUniform!(1, "mMaterialIndex")({return cast(float[])[materialIndex];});
      if (texture !is null) _custom.setTexture(texture);
      _custom.endMesh();
    }

    int id() @nogc {
      return _id;
    }

    vec4[] vertices() @nogc {
      return _vertices;
    }

    vec3[] normals() @nogc {
      return _normals;
    }

    vec2[] texCoords() @nogc {
      return _texCoords;
    }

    uint[] indices() @nogc {
      return _indices;
    }

    int materialIndex() @nogc {
      return _materialIndex;
    }

    //float[] vertices() {
    //    return _changedVertices;
    //}
    //
    //float[] normals() {
    //    return _changedNormals;
    //}
    //
    //float[] texCoords() {
    //    return _changedTexCoords;
    //}
    //
    //uint[] indices() {
    //    return _changedIndices;
    //}

    vec4 diffuse() @nogc {
      return _diffuse;
    }

    vec4 specular() @nogc {
      return _specular;
    }

    vec4 ambient() @nogc {
      return _ambient;
    }

    TextureObject texture() @nogc {
      return _texture;
    }

    void draw(){
      if(_vertices.length != _texCoords.length)return;
      _custom.draw;
    }

}
