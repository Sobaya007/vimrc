module sbylib.utils.Stack;

struct Stack(T) {

	private class Node {
		T elem;
		Node prev, next;
		this(T elem) {this.elem = elem;}
	}

	private {
		Node last;
		bool isAllocated;
		size_t length; // Stackに入ってるNodeの数
		Node[] allocatedNodes = [];
	}

	void push(T elem) in {
		assert(!isAllocated || length < allocatedNodes.length);
	} body {
		if (last is null) {
			if (isAllocated) {
				last = allocatedNodes[length];
				last.elem = elem;
				last.next = null;
			} else {
				last = new Node(elem);
			}
			length++;
			return;
		}
		Node next;
		if (isAllocated) {
			next = allocatedNodes[length];
			next.elem = elem;
			next.next = null;
		} else {
			next = new Node(elem);
		}
		last.next = next;
		next.prev = last;
		this.last = next;
		length++;
	}

	void pop() @nogc in {
		assert(length > 0);
	} body {
		if (last.prev is null) {
			last = null;
			return;
		}
		auto n = last.prev;
		n.next = null;
		this.last = n;
		length--;
	}

	int opApply(int delegate(ref T) dg) {
		auto current = last;
		if (current is null) return 0;
		while (current.prev) current = current.prev;
		int result = 0;
		while (current) {
			result = dg(current.elem);
			if (result) break;
			current = current.next;
		}
		return result;
	}

	void clear() @nogc {
		length = 0;
		last = null;
	}

	void allocate(size_t leng) in {
		assert(leng >= length);
		assert(leng >= allocatedNodes.length);
	} body {
		allocatedNodes.length = leng;
		size_t i = length;
		Node current = last;
		while(current) {
			allocatedNodes[--i] = current;
			current = current.next;
		}
		assert(i == 0);
		i = length;
		for(; i<allocatedNodes.length; i++) {
			allocatedNodes[i] = new Node(T.init);
		}
		isAllocated = true; // 静的配列モード
	}

	alias removeBack = pop;
	alias insertBack = push;
}