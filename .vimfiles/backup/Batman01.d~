module enemy.Batman01;

import sbylib;
import collision;
import enemy.EnemyCollisionObject;
import enemy.GameAI;

class Batman01 : GameAI {
  static{
    const int preLimit = 2*10;
    const float preAngle = 2 * PI * (90.0/360.0) / to!float(preLimit);
    vec3 gravity = vec3(0.0,-0.98,0.0);
    vec3 up = vec3(0.0,1.0,0.0);
  }
  private double angle = 30.0;   //羽ばたく速さ
  private double theta = PI / 180;
  private double size = 0.30;
  private vec3 dir = vec3(0.0,0.0,1.0);
  private vec3 predir = vec3(0.0,0.0,1.0);
  private bool IsDush = false; //ダッシュしてるか
  private vec3 migi;
  private vec3 hidari;
  private vec3 bodyaxis;
  // 	int[][] indices;
  float h = -1.0;
  float gyou = 150.0;   //翼の可動域(°)
  float turnangle = 0.0;
  float range = 10.0;
  float nsp = 0.0;
  bool isAttacking = true; //攻撃可能か
  bool isCounting = false;
  bool readyAttack = false;
  bool isNotice = false;

  int delegate() countPrepare;
  CustomObject custom;
  private EnemyCollisionObject attackCollisionObject;

  this(Octree tree,Material mat = null)  {

    if (mat is null){
      mat = new Material();
    }
    TextureObject tex = new TextureObject(SbyWorld.rootPath ~ "Resource/traP.png");

    pos(vec3(0.0,5.0,0.0));

    indices = [
      [5,2,0], //奥
      [5,1,2], //手前
      [5,0,3], //上
      [5,3,1], //下
      [4,2,1], //奥
      [4,0,2], //手前
      [4,3,0], //上
      [4,1,3], //下
      [8,4,9],
      [4,6,9],
      [7,8,9],
      [6,7,9],
      [8,7,10],
      [7,6,10],
      [6,4,10],
      [4,8,10],
      [14,12,11],
      [14,11,5],
      [14,5,13],
      [14,13,12],
      [15,5,11],
      [15,13,5],
      [15,12,13],
      [15,11,12]
        ];

      vertices = [
        vec4(-1.5,0,0,1f), //体
        vec4(+1.5,0,0,1),
        vec4(0,+0.5,0,1),
        vec4(0,-0.5,0,1),
        vec4(0,0,0.5,1),
        vec4(0,0,-0.5,1),
        vec4(-2,0,3,1),  //右翼
        vec4(1,0,5,1),
        vec4(2,0,3,1),
        vec4(1,0.25,3,1),
        vec4(1,-0.25,3,1),
        vec4(-2,0,-3,1), //左翼
        vec4(1,0,-5,1),
        vec4(2,0,-3,1),
        vec4(1,0.25,-3,1),
        vec4(1,-0.25,-3,1)
      ];
      bodyaxis = rotate(vec3(1.0,0.0,0.0),dir.normalize,toRad(-90.0));
      bodyaxis = rotate(bodyaxis,vec3(0.0,1.0,0.0),toRad(-90.0));
      foreach(ref v ; vertices){
        vec3 temp = ftot(v);    //vの0,1,2番目の要素でvec3を作成
        //temp = rotate(temp,dir.normalize,toRad(90.0));
        temp = rotate(temp,vec3(0.0,1.0,0.0),toRad(-90.0));
        v = ttof(temp);         //vec3に1を付け足してvec4を作成
      }

      migi = ftot(vertices[4]);
      hidari = ftot(vertices[5]);
      foreach(i ; 6..11){
        vec3 temp = ftot(vertices[i]);
        temp = rotate(temp,migi,dir.normalize,toRad(gyou/2.0));
        vertices[i] = ttof(temp);
      }
      foreach(i ; 11..16){
        vec3 temp = ftot(vertices[i]);
        temp = rotate(temp,hidari,dir.normalize,toRad(-gyou/2.0));
        vertices[i] = ttof(temp);
      }
      foreach(ref v ; vertices) v *=size;

      vec2[4] tc = [
        vec2(0,0),
        vec2(1,0),
        vec2(1,1),
        vec2(0,1)
      ];

      vec4[] vertex2;
      foreach (i; indices) {
        foreach (j; i) {
          vertex2 ~= vertices[j];
        }
      }
      vec2[] tc2;
      foreach (i; 0..indices.length) {
        foreach (j; 0..3) {
          tc2 ~= tc[j];
        }
      }

      alias conv = reduce!((a,b) => a ~ b.array);
      custom = new CustomObject(mat, ShaderStore.getShader("TextureShow"), Prim.Triangle);
      custom.beginMesh;
      custom.addAttribute!(2, "mTexcoord")(conv(cast(float[])[], tc2), GpuSendFrequency.Static);
      custom.addAttribute!(4, "mVertex")(conv(cast(float[])[], vertex2), GpuSendFrequency.Static);
      custom.setIndex(iota(cast(uint)vertex2.length).array, GpuSendFrequency.Static);
      custom.setTexture(tex);
      custom.addDynamicUniformMatrix!(4, "mWorld")({return this.getWorldMatrix.array;});
      custom.addDynamicUniformMatrix!(4, "mViewProj")({return SbyWorld.currentCamera.getViewProjectionMatrix().array;});
      custom.endMesh;
      //衝突応答を作成
      addCollisionObject(tree);
      collisionObject.listener = (std.container.Array!CollisionInfo collisionInfo) {
        foreach (info; collisionInfo) {
          writeln("hit");
        }
      };
      collisionObject.update();
      //攻撃用オブジェクト作成
      createColObj(tree);
  }

  //攻撃用の衝突オブジェクトを作成
  void createColObj(Octree tree){
    //頂点の基とするもの
    auto vertex = [
      vec4(-1,-1,-1,1f),
      vec4(+1,-1,-1,1),
      vec4(-1,+1,-1,1),
      vec4(+1,+1,-1,1),
      vec4(-1,-1,1,1),
      vec4(+1,-1,1,1),
      vec4(-1,+1,1,1),
      vec4(+1,+1,1,1)
    ];
    foreach (ref v;vertex){
      v *= 0.5;
      v[3] = 1;
    }
    //頂点のそれぞれの面の描画順序
    uint[][6] index = [
      [4,5,0,1], //下
      [6,7,4,5], //手前
      [0,1,2,3], //奥
      [2,3,6,7], //上
      [5,7,1,3], //左
      [0,2,4,6]  //右
    ];
    vec4[] vertex2;
    foreach (i; 0..6) {
      vertex2 ~= vertex[index[i][0]];
      vertex2 ~= vertex[index[i][1]];
      vertex2 ~= vertex[index[i][2]];
      vertex2 ~= vertex[index[i][2]];
      vertex2 ~= vertex[index[i][1]];
      vertex2 ~= vertex[index[i][3]];
    }
    uint[][] tempIndices;
    foreach (i; 0..12) {
      tempIndices ~= cast(uint[])[i*3, i*3+1, i*3+2].reverse;
    }
    //衝突判定を追加
    attackCollisionObject = new EnemyCollisionObject(vertex2,tempIndices);
    attackCollisionObject.setOctree(tree);
    attackCollisionObject.listener = (std.container.Array!CollisionInfo collisionInfo) {
      foreach (info; collisionInfo) {
        writeln("hit");
        assert(false);
      }
    };
    attackCollisionObject.addToOctree();
    attackCollisionObject.listener = (std.container.Array!CollisionInfo collisionInfo) {
      foreach (info; collisionInfo) {
        writeln("hit");
        assert(false);
      }
    };
    attackCollisionObject.update; //octre

  }
  //攻撃用の衝突オブジェクトの座業を更新
  void updateAttackObject(){
    //口先に合わせる
    if (attackCollisionObject !is null) {
      //attackCollisionObject.listener(attackCollisionObject.collisionInfo);
      //attackCollisionObject.clearInfo();
      attackCollisionObject.shape.Position = vertices[1].xyz + getPos;
      attackCollisionObject.shape.update();
    }
    attackCollisionObject.update();
  }

  private int ind = 0;
  void fly(){
    ind = (ind + 1) % (2*to!int(gyou/angle));   //１周期のうちどのあたりに今あるか
    float t = 2.0 * 3.14159265 * to!float(ind) / (2*to!int(gyou/angle));  //翼に合わせて体全体も上下させる
    pos( getPos() - 0.1*cos(t)*vec3(0.0,1.0,0.0));                   

    if(ind < to!int(gyou/angle) ) h = -1.0;     //半周期以下なら
    else h = 1.0;                               //半周期以降なら逆方向に翼を回転
    //羽ばたく
    migi = ftot(vertices[4]);    //右肩の位置を更新
    hidari = ftot(vertices[5]);  //左肩の位置を更新
    //右肩を中心に右翼を回転
    foreach(i ; 6..11){
      vec3 temp = ftot(vertices[i]);
      temp = rotate(temp,migi,dir.normalize,toRad(angle*h));
      vertices[i] = ttof(temp);
    }
    //左肩を中心に左翼を回転
    foreach(i ; 11..16){
      vec3 temp = ftot(vertices[i]);
      temp = rotate(temp,hidari,dir.normalize,toRad(-angle*h));
      vertices[i] = ttof(temp);
    }

    updateVertices();
  }

  void updateVertices(){
    //描画
    vec4[] vertex2;
    foreach (i; indices) {
      foreach (j; i) {
        vertex2 ~= vertices[j];
      }
    }
    alias conv = reduce!((a,b) => a ~ b.array);
    custom.update("mVertex", conv(cast(float[])[], vertex2));
  }

  void attack(float d){

    nsp +=  0.05 * d;
    nsp = min(10,nsp);
    nsp = max(0.5,nsp);
    vertices[1]= vec4(vertices[1].xyz*min(10,nsp),1.0);
    if(vertices[1].xyz.length < size*1.5){
      vertices[1].xyz = vertices[1].xyz.normalize * 1.5*size;
      isAttacking = true;
    }
    if(vertices[1].xyz.length > size*15){
      vertices[1].xyz = vertices[1].xyz.normalize * 15*size;
      isAttacking = false;;
    }


    updateVertices();
  }

  int t = 0;
  int y = 0;
  vec3 preVec = vec3(1.0,0.0,0.0);
  void beforAttack(){
    t += 1;
    y += 2*t;
    foreach(ref v ; vertices){
      v += vec4(preVec.normalize() * t + vec3(0.0,to!float(y),0.0),0.0);
    }
    updateVertices();
  }

  void prepareAttack(int c){
    float h = 2*c - preLimit > 0 ? -1 : 1;
    pos(getPos() + 0.05 * (up - dir.normalize()) * h);
  }

  void move(){

    //プレイヤーの存在に気づいているか
    if(isNotice){
      //進行方向を回転
      auto distance = getDistance;
      //distanceのy成分をほぼ0に(0にするとダメ)
      distance.y *= 0.00000001;
      auto ld = distance.length;

      //dirのy成分をほぼ0に(0にするとダメ)
      dir.y *= 0.00000001;
      //distanceのy成分を元に戻す
      distance.y *= 10000000;
      dir.y = distance.y;
      //攻撃してない and 攻撃準備モーション中ではない
      if(isAttacking && !isCounting){
        turnangle += getAng(dir,distance) * distance.length^^4 * 0.001 ;
        turnangle = min(0.05,turnangle);
        turn(turnangle,up);
      }

      //dirのy成分をほぼ0に(0にするとダメ)
      dir.y *= 0.0000001;
      if(!isAttacking && vertices[1].xyz.length > size*1.5){
        attack(-1.0);
      }

      //射程距離外ならば
      if(ld > 3.5 ){
        //速度に合わせて移動
        pos(getPos() + dir * 0.1 + vec3(0.0,distance.y,0.0)*0.1);
        readyAttack = false;
      }else{ //射程距離内に入ったならば
        if( (isAttacking && turnangle < 0.1) || isCounting){
          //攻撃準備ができた
          if(readyAttack){
            attack(1.0);
          }else{
            //攻撃準備モーション中
            if(!isCounting){
              isCounting = true;
              getCounter(countPrepare);
            }else{
              countQuery();
            }
          }
          //口先が伸びすぎてる and 攻撃が終了した。
        }else if(!isAttacking && vertices[1].xyz.length > size*1.5){
          attack(-1.0);
          readyAttack = false;
        }
      }
      //プレイヤーの存在に気づいていない
    }else{

      //口先が伸びすぎてる and 攻撃が終了した。
      if(!isAttacking && vertices[1].xyz.length > size*1.5){
        attack(-1.0);
      }
      //攻撃準備モーションならそれを続ける
      if(isCounting){
        countQuery();
      }
      turn(theta,up);
      pos(getPos() + dir * 0.25);
    }

    //飛行モーション
    fly();

  }

  //攻撃準備モーションフラグ(isCounting)が立っている時の処理
  void countQuery(){
    //c := 今何フレーム目か
    int c = countPrepare();
    //攻撃準備モーション
    prepareAttack(c);
    if(c >= preLimit){
      readyAttack = true;
      isCounting = false;
    }
  }

  void turn(double ang,vec3 axis) {
    dir = rotate(dir,axis,ang);
    bodyaxis = rotate(bodyaxis,axis,ang);
    foreach(ref i ; vertices){
      i = ttof( rotate(ftot(i),axis,ang) );
    }
    migi  = ftot(vertices[4]);
    hidari = ftot(vertices[5]);


    vec4[] vertex2;
    foreach (i; indices) {
      foreach (j; i) {
        vertex2 ~= vertices[j];
      }
    }
    alias conv = reduce!((a,b) => a ~ b.array);
    custom.update("mVertex", conv(cast(float[])[], vertex2));
  }

  void getCounter(ref int delegate() dg){
    int count = 0;
    int counter(){
      count++;
      return count;
    }
    dg = &counter;
  }

  override bool draw() {
    move();
    // 		custom.draw();

    return true;
  }

  override bool step(){
    if(dir.length > 0){
      predir = dir;
    }
    if(getDistance.length <= range){
      isNotice = true;
    }else{
      isNotice = false;
    }
    reactCollision();
    transFormCollision();
    updateAttackObject();

    return true;
  }

}
