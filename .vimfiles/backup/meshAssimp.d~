module model.modelloader.meshAssimp;

import model.imports;

class Mesh_Assimp {

private:
	bool _initFlag = false;

	vec4[] _vertices;
	vec3[] _normals;
	vec2[] _texCoords;
	uint[] _indices;
	int _materialIndex;
	Material_Assimp _material;

public:
	this(aiMesh* mesh, Material_Assimp[] materials) in {
		assert(mesh !is null);
	} body {
		with(mesh) {
			_vertices = mVertices[0..mNumVertices].map!(v => vec4(v.x, v.y, v.z, 1.0)).array;
			_normals = mNormals[0..mNumVertices].map!(v => vec3(v.x, v.y, v.z)).array;
			_texCoords = (mTextureCoords[0] is null) ? [] : mTextureCoords[0][0..mNumVertices].map!(t => vec2(t.x, t.y)).array;
			_indices = mFaces[0..mNumFaces].map!(f => f.mIndices[0..f.mNumIndices]).array.join.array.reverse; // reverse?
			_materialIndex = mMaterialIndex;
			_material = (mMaterialIndex < materials.length) ? materials[mMaterialIndex] : null;
			_materialIndex = mMaterialIndex;

			assert(_vertices.length == _normals.length);
			assert(_indices.length%3 == 0);

			//{ // 法線の計算
			//    _normals.length = _vertices.length;
			//    for(int i=0; i<_indices.length; i+=3) {
			//        vec4 v1 = _vertices[_indices[i+1]] - _vertices[_indices[i+0]];
			//        vec4 v2 = _vertices[_indices[i+2]] - _vertices[_indices[i+1]];
			//        vec3 v = -cross(vec3(v1.x, v1.y, v1.z), vec3(v2.x, v2.y, v2.z)).normalize;
			//        _normals[_indices[i+0]] = v;
			//        _normals[_indices[i+1]] = v;
			//        _normals[_indices[i+2]] = v;
			//    }
			//}

			//writeln("vertices: ", _vertices);
			//writeln("normals: ", _normals);
			//writeln("texCoords: ", _texCoords);
			//writeln("indices: ", _indices);
		}
		_initFlag = true;
	}

	vec4[] vertices() @nogc {
		return _vertices;
	}

	vec3[] normals() @nogc {
		return _normals;
	}

	vec2[] texCoords() @nogc {
		return _texCoords;
	}

	uint[] indices() @nogc {
		return _indices;
	}

	int materialIndex() @nogc {
		return _materialIndex;
	}

	Material_Assimp material() @nogc {
		return _material;
	}

	void multMatrix(mat4 matrix) {
		_vertices = _vertices.map!(v => matrix*v).array;
		_normals = _normals.map!(n => matrix * vec4(n.x, n.y, n.z, 0.0)).map!(n => vec3(n.x, n.y, n.z)).array;

		{ // 法線の計算
			_normals.length = _vertices.length;
			for(int i=0; i<_indices.length; i+=3) {
				vec4 v1 = _vertices[_indices[i+1]] - _vertices[_indices[i+0]];
				vec4 v2 = _vertices[_indices[i+2]] - _vertices[_indices[i+1]];
				vec3 v = -cross(vec3(v1.x, v1.y, v1.z), vec3(v2.x, v2.y, v2.z)).normalize;
				_normals[_indices[i+0]] = v;
				_normals[_indices[i+1]] = v;
				_normals[_indices[i+2]] = v;
			}
		}
	}

}
