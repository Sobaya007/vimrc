module sbylib.physics3d.Contact;

import sbylib;
import sbylib.physics3d.RigidBody3D;

struct Contact {
  vec3 normal, pos, tan, bin;
  vec3 totalImpact;
  float penetration;
  Shape a, b;
  float massInvA, massInvB;
  float restitution;
  float friction;
  vec3 nTorqueA;
  vec3 nTorqueB;
  vec3 tTorqueA;
  vec3 tTorqueB;
  vec3 bTorqueA;
  vec3 bTorqueB;
  vec3 nTorqueUnitA;
  vec3 nTorqueUnitB;
  vec3 tTorqueUnitA;
  vec3 tTorqueUnitB;
  vec3 bTorqueUnitA;
  vec3 bTorqueUnitB;
  float normalDenominator;
  float tanDenominator;
  float binDenominator;
<<<<<<< HEAD
  float targetNormalLinearVelocity;
=======
  float targetNormalVelocity;
>>>>>>> crystal_fix
  float normalImpulse;
  float tanImpulse;
  float binImpulse;

  @nogc this(vec3 pushVec, vec3 pos, RigidBody3D a, RigidBody3D b) {
    this.penetration = pushVec.length;
    this.normal = pushVec / penetration;
    this.pos = pos;
    this.totalImpact = vec3(0);
    this.a = a.shape;
    this.b = b.shape;
    this.massInvA = a.massInv;
    this.massInvB = b.massInv;
    this.restitution = a.restitution * b.restitution;
    this.friction = a.friction * b.friction;
    this.normalImpulse = 0;
    this.tanImpulse = 0;
    this.binImpulse = 0;

    auto rVel = a.getVelocity(pos) - b.getVelocity(pos);
    auto nVel = dot(rVel, normal);
    this.tan = rVel - nVel * normal;
    auto len = tan.lengthSq;
    if (len > 1e-2) tan /= sqrt(len);
    else {
      tan = vec3(normal.y * normal.x - normal.z * normal.z,
          -normal.z * normal.y - normal.x * normal.x,
          normal.x * normal.z + normal.y * normal.y)
        .normalize;
    }
    this.bin = cross(normal, tan);
<<<<<<< HEAD
    auto ra = pos - a.shape.Position;
    auto rb = pos - b.shape.Position;
=======
    auto ra = pos - a.shape.pos;
    auto rb = pos - b.shape.pos;
>>>>>>> crystal_fix
    nTorqueA = cross(ra, normal);
    nTorqueB = cross(rb, normal);
    tTorqueA = cross(ra, tan);
    tTorqueB = cross(rb, tan);
    bTorqueA = cross(ra, bin);
    bTorqueB = cross(rb, bin);
    nTorqueUnitA = a.worldInertiaInv * nTorqueA;
    nTorqueUnitB = b.worldInertiaInv * nTorqueB;
    tTorqueUnitA = a.worldInertiaInv * tTorqueA;
    tTorqueUnitB = b.worldInertiaInv * tTorqueB;
    bTorqueUnitA = a.worldInertiaInv * bTorqueA;
    bTorqueUnitB = b.worldInertiaInv * bTorqueB;
    normalDenominator = 1 / (a.massInv + b.massInv + dot(normal, cross(nTorqueUnitA, ra) + cross(nTorqueUnitB, rb)));
    tanDenominator = 1 / (a.massInv + b.massInv + dot(tan, cross(tTorqueUnitA, ra) + cross(tTorqueUnitB, rb)));
    binDenominator = 1 / (a.massInv + b.massInv + dot(bin, cross(bTorqueUnitA, ra) + cross(bTorqueUnitB, rb)));

    //if (nvel > -0.02) {
    //    nvel = 0;
    //}
<<<<<<< HEAD
    targetNormalLinearVelocity = restitution * -nVel;
    auto separationVelocity = penetration - 0.05;
    if (separationVelocity > 0) {
      separationVelocity *= 60 * 0.05;
      if (targetNormalLinearVelocity < separationVelocity) {
        targetNormalLinearVelocity = separationVelocity;
=======
    targetNormalVelocity = restitution * -nVel;
    auto separationVelocity = penetration - 0.05;
    if (separationVelocity > 0) {
      separationVelocity *= 60 * 0.05;
      if (targetNormalVelocity < separationVelocity) {
        targetNormalVelocity = separationVelocity;
>>>>>>> crystal_fix
      }
    }
  }

  @nogc void solve() {
<<<<<<< HEAD
    auto nVel = dot(a.LinearVelocity - b.LinearVelocity, normal) + dot(nTorqueA, a.AngularVelocity) - dot(nTorqueB, b.AngularVelocity);
    auto oldImpulse1 = normalImpulse;
    auto newImpulse1 = (nVel - targetNormalLinearVelocity) * normalDenominator * 1.4;
=======
    auto nVel = dot(a.lVel - b.lVel, normal) + dot(nTorqueA, a.aVel) - dot(nTorqueB, b.aVel);
    auto oldImpulse1 = normalImpulse;
    auto newImpulse1 = (nVel - targetNormalVelocity) * normalDenominator * 1.4;
>>>>>>> crystal_fix
    normalImpulse += newImpulse1;
    if (normalImpulse > 0) normalImpulse = 0;
    newImpulse1 = normalImpulse - oldImpulse1;
    auto force = normal * newImpulse1;
<<<<<<< HEAD
    a.LinearVelocity -= force * massInvA;
    a.AngularVelocity -= nTorqueUnitA * newImpulse1;
    b.LinearVelocity += force * massInvB;
    b.AngularVelocity += nTorqueUnitB * newImpulse1;

    auto maximum = -normalImpulse * friction;
    auto rVel = a.LinearVelocity - b.LinearVelocity;
    auto tVel = dot(rVel, tan) + dot(a.AngularVelocity, tTorqueA) - dot(b.AngularVelocity, tTorqueB);
=======
    a.lVel -= force * massInvA;
    a.aVel -= nTorqueUnitA * newImpulse1;
    b.lVel += force * massInvB;
    b.aVel += nTorqueUnitB * newImpulse1;

    auto maximum = -normalImpulse * friction;
    auto rVel = a.lVel - b.lVel;
    auto tVel = dot(rVel, tan) + dot(a.aVel, tTorqueA) - dot(b.aVel, tTorqueB);
>>>>>>> crystal_fix
    oldImpulse1 = tanImpulse;
    newImpulse1 = tVel * tanDenominator;
    tanImpulse += newImpulse1;

<<<<<<< HEAD
    auto bVel = dot(rVel, bin) + dot(a.AngularVelocity, bTorqueA) - dot(b.AngularVelocity, bTorqueB);
=======
    auto bVel = dot(rVel, bin) + dot(a.aVel, bTorqueA) - dot(b.aVel, bTorqueB);
>>>>>>> crystal_fix
    auto oldImpulse2 = binImpulse;
    auto newImpulse2 = bVel * binDenominator;

    auto len = tanImpulse^^2 + binImpulse^^2;
    if (len > maximum^^2) {
      len = maximum / sqrt(len);
      tanImpulse *= len;
      binImpulse *= len;
    }

    newImpulse1 = tanImpulse - oldImpulse1;
    newImpulse2 = binImpulse - oldImpulse2;

    force = tan * newImpulse1 + bin * newImpulse2;
<<<<<<< HEAD
    a.LinearVelocity -= force * massInvA;
    a.AngularVelocity -= tTorqueUnitA * newImpulse1 + bTorqueUnitA * newImpulse2;
    b.LinearVelocity += force * massInvB;
    b.AngularVelocity += tTorqueUnitB * newImpulse1 + bTorqueUnitB * newImpulse2;
=======
    a.lVel -= force * massInvA;
    a.aVel -= tTorqueUnitA * newImpulse1 + bTorqueUnitA * newImpulse2;
    b.lVel += force * massInvB;
    b.aVel += tTorqueUnitB * newImpulse1 + bTorqueUnitB * newImpulse2;
>>>>>>> crystal_fix

  }
}
