module collision.collisionObject.tripolygon;

import collision.imports;

import sbylib.gl.Constants;
import sbylib.gl.VertexArrayObject;
import sbylib.gl.VertexBufferObject;
import sbylib.gl.IndexBufferObject;
import sbylib.utils.CustomObject;
import sbylib.gl.Material;
import sbylib.gl.ShaderProgram;
static import sbylib.core.World;

class Tripolygon : CollisionObject {

  private:
    vec3[] _vertices;
    vec3 _normal;
    vec3 _center;

    CustomObject _custom;

  public:
    this(vec4[] vertices, vec4 normal) {
      this(vertices.map!(v => vec3(v.x, v.y, v.z)).array, vec3(normal.x, normal.y, normal.z));
    }

    this(vec4[] vertices, vec3 normal) {
      this(vertices.map!(v => vec3(v.x, v.y, v.z)).array, normal);
    }

    this(vec3[] vertices, vec3 normal) {
      assert(vertices.length==3);
      _vertices = vertices;
      _normal = normal.normalize;
      _center = vertices.sum / vertices.length;
      init();
      import sbylib;
      super(new PhysicalPolygon(vertices));
    }

    override void update() {
      updateAABB();
      super.update();
    }

<<<<<<< HEAD
    override uint getOrder() {
      return 10;
    }

=======
>>>>>>> crystal_fix
    vec3[] vertices() @nogc {
      return _vertices;
    }

    vec3 normal() @nogc {
      return _normal;
    }

    vec3 center() @nogc {
      return _center;
    }

    override bool draw() {
      _custom.draw();
      return true;
    }
  protected:
    void init() {
      listener = (Array!CollisionInfo info){};
      //setCustomObject(); //
      updateAABB();
    }

    void updateAABB() {
      _aabb.minimum = vec3(float.infinity);
      _aabb.maximum = vec3(-float.infinity);
      _vertices.each!((v){
          _aabb.minimum.x = min(_aabb.minimum.x, v.x);
          _aabb.minimum.y = min(_aabb.minimum.y, v.y);
          _aabb.minimum.z = min(_aabb.minimum.z, v.z);
          _aabb.maximum.x = max(_aabb.maximum.x, v.x);
          _aabb.maximum.y = max(_aabb.maximum.y, v.y);
          _aabb.maximum.z = max(_aabb.maximum.z, v.z);
          });
      _aabb.maximum += 0.5;
      _aabb.minimum -= 0.5;
    }

    void setCustomObject() {
      ShaderProgram sp = new ShaderProgram(
          "#version 330
      in vec4 mVertex;
      in vec3 mNormal;
      uniform mat4 mWorld;
      uniform mat4 mViewProj;
      out vec3 n;

      void main() {
      gl_Position = mViewProj * mWorld * mVertex;
      mat3 m2 = mat3(mWorld[0].xyz,mWorld[1].xyz,mWorld[2].xyz);
      n = normalize(m2 * mNormal);
      }
      ",
      "#version 330
      in vec3 n;
      out vec4 FragColor;
      void main() {
      FragColor = vec4(n*.5,.5);
      }
      ",
        ShaderProgram.InputType.SourceCode);
      _custom = new CustomObject(new Material, sp, Prim.Triangle);

      _custom.beginMesh();
      _custom.addAttribute!(3, "mVertex")(_vertices.map!(v => [v.x, v.y, v.z]).array.join, GpuSendFrequency.Static);
      _custom.addAttribute!(3, "mNormal")(3.iota.array.map!(n=>[_normal.x, _normal.y, _normal.z]).array.join, GpuSendFrequency.Static);
      _custom.setIndex([0,1,2], GpuSendFrequency.Static);
      _custom.addDynamicUniformMatrix!(4, "mWorld")({return mat4.identity.array;});
      _custom.addDynamicUniformMatrix!(4, "mViewProj")({return sbylib.core.World.SbyWorld.currentCamera.getViewProjectionMatrix().array;});
      _custom.endMesh();
    }
}
