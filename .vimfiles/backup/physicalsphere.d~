module sbylib.physics3d.PhysicalSphere;

import sbylib;
import sbylib.physics3d.Shape;

class PhysicalSphere : Shape {
  private:
    float radius;
  public:
    this(float r) {
      this.radius = r;
      super();
    }

    void setRadius(float r) {
      this.radius = r;
    }

    float getRadius() {
      return radius;
    }
override:

    float computeVolume() {
      return radius ^^3 * PI * 4 / 3;
    }

    mat3 computeInertiaTensor() {
      return mat3.scale(vec3(radius^^2 * 2 / 5));
    }

    CustomObject createCustomObject() {
      auto mat = new Material;
      auto custom = new Sphere(mat, ShaderStore.getShader("NormalGenerate")).getCustomObject;
      custom.setUniformMatrix!(4, "mWorld")(mat4.identity.array);
      custom.addDynamicUniformMatrix!(4, "mViewProj")({return SbyWorld.currentCamera.getViewProjectionMatrix.array;});
      return custom;
    }

    vec3 getMaxPoint() {
<<<<<<< HEAD
      return Position + vec3(radius);
    }

    vec3 getMinPoint() {
      return Position - vec3(radius);
    }

    void updateCustomObject(CustomObject custom) {
      mat4 mWorld = mat4.translate(Position) * Orientation.toMatrix4;
=======
      return pos + vec3(radius);
    }

    vec3 getMinPoint() {
      return pos - vec3(radius);
    }

    void updateCustomObject(CustomObject custom) {
      mat4 mWorld = mat4.translate(pos) * orientation.toMatrix4;
>>>>>>> crystal_fix
      custom.setUniformMatrix!(4, "mWorld")(mWorld.array);
    }

    vec3 support(vec3 d) {
<<<<<<< HEAD
      return Position + d * radius;
=======
      return pos + d * radius;
>>>>>>> crystal_fix
    }

    Face supportFace(vec3 d) {

      vec3 getVertical(vec3 v) {
        if (v.x == 0 && v.y == 0) {
          if (v.z == 0) assert(false);
          return vec3(1,0,0);
        }
        return v.cross(vec3(0,0,1));
      }

      //微小面積の面を一応作っておくことにする
      //サポート頂点のまわりに半径0.1の五角形を作る
      auto v = getVertical(d) * 0.2;
      Face face = new Face();
      auto p = support(d);
      quat rot = quat.createAxisAngle(d, 2 * PI / 5);
      foreach (i; 0..5) {
        Vertex vertex =  new Vertex(p + v);
        vertex.worldPosition = vertex.position;
        vertex.faces ~= face;
        face.vertices ~= vertex;
        face.normal = d;

        v = rotate(v, rot);
      }
      return face;
    }
}
