module sbylib.entity.CameraChaser;
import sbylib;

class CameraChaser : Entity {


  protected :
    WorldObject target;
    WorldObject focus;
    Camera camera;
    vec3 toCamera;
    float defaultDistance;
    float defaultY;
    vec3 spd = vec3(0,0,0);

    immutable k = 0.003;
    immutable c = 0.05;
  public:

    this(Camera camera, WorldObject focus) {
      this.camera = camera;
      this.focus = focus;
      toCamera = camera.getPos - focus.getPos;
      defaultDistance = toCamera.xz.length;
      defaultY = toCamera.y;
    }

    override bool step() {

      with(camera) {
        auto d = getPos - focus.getPos;
        d.y = 0;
        auto len = d.length;
        d /= len;

        len -= defaultDistance;
        d *= len;
        spd -= d * k + spd * c;
        pos = getPos + spd;
        pos = vec3(getPos.x, focus.getPos.y + defaultY, getPos.z);

        vecZ = (getPos - focus.getPos).normalize;
        vecX = cross(vec3(0,1,0), getVecZ).normalize;
        vecY = cross(getVecZ, getVecX).normalize;

        if (Input.pressed(KeyButton.W)) {
          defaultDistance -= .1;
        }
        if (Input.pressed(KeyButton.S)) {
          defaultDistance += .1;
        }

        auto omega = .1145141919810 / 4 * Input.joySticks[0].getAxis(JoyStick.Axis.RightX);
        auto v = SbyWorld.currentCamera.getPos - focus.getPos;
        auto rot = mat4.rotAxisAngle(vec3(0,1,0), omega);
        v = (rot * vec4(v, 1)).xyz;
        with (SbyWorld.currentCamera) {
          pos = focus.getPos + v;
          vecX = (rot * vec4(getVecX, 0)).xyz;
          vecY = (rot * vec4(getVecY, 0)).xyz;
          vecZ = (rot * vec4(getVecZ, 0)).xyz;
        }

        static vec2 beforeMousepos;
        vec2 mousepos = Input.mousePos;
        if (Input.pressed(MouseButton.Button1)) {
          const float delta = 0.005;
          auto mat = mat4.translate(focus.getPos) * mat4.rotFromTo(getVecZ, normalize(getVecZ
                + getVecX * (delta * (mousepos.x - beforeMousepos.x))
                - getVecY * (delta * (mousepos.y - beforeMousepos.y)))) * mat4.translate(-focus.getPos);
          pos = (mat * vec4(getPos, 1)).xyz;
          vecZ = (mat * vec4(getVecZ, 1)).xyz;
          defaultY = getPos.y - focus.getPos.y;
        }
        vecZ = normalize(getPos - focus.getPos);
        vecX = normalize(cross(getVecY, getVecZ));
        vecY = cross(getVecZ, getVecX).normalize;
        beforeMousepos = mousepos;
      }

      return true;
    }

    override string toString() {
      return "CameraChaser";
    }
}

