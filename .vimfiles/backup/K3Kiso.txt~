来週4/29(金)　中間試験
範囲　2章　チューリング機械
				3.1節　原子帰納的関数    //3.1節はやらないかも？
							 帰納的関数
持ち込み不可

多テープチューリング機械 //テープを増やすことで計算力が上がるのでは？
	テープを複数本持ったチューリング機械
	M<k, Q, δ, Σ, Γ>で定義
	 k=テープ本数
	 Q=状態集合
	 δ=状態遷移関数
	 Σ=入出力記号
	 Γ=テープ記号
	 kテープチューリングマシン(今までのチューリングマシン-> 「標準チューリング機
	 械」）


	 | | | | | | | 
	    ^
	 | | | | | | |       + □ 
	         ^
	 | | | | | | | 
	      ^
				
	δ:(Q-{q_fin}) x (Γ)^k から　Q x (Γ x {L,R,N})^kへの有限関数
	
	計算状況は組(q, (ω1, ω1'), ... , (ωK, ωK'))
																			で表す

  1番目のテープが入出力テープ
	 (q0, (ε,x), (ε,ε), ..., (ε,ε))     入力xに対する初期状況
	 (q_fin, (ε,y), (ε,ε), ..., (ε,ε))  yを出力とする正常終了状態


例.与えられた記号列が等しいかどうかを判定するチューリング機械 M_eq

アイディア
|B|B|B|B|B|B|x|x|x|x|#|y|y|y|y|B|B|B|B|B|B|

|B|B|B|B|B|B|x|x|x|x|B|B|B|B|B|B|B|B|B|B|B| //xだけコピー

|B|B|B|B|B|B|y|y|y|y|B|B|B|B|B|B|B|B|B|B|B| //yだけコピー

この後2本目と3本目のテープを前から比較していき、最後まで行ったら1を、だめなら
残りを消して0を出力

	M_eq<3, Q, δ, Σ, Γ>

例.足し算を行うチューリング機械 M_add
アイディア：２つコピーして下の桁から足す

多テープチューリング機械の計算能力
	多テープチューリング機械Mに対し、それをシミュレートする標準チューリング機械
	M'が構成可能

	2テープチューリング機械を1テープチューリング機械でシミュレートできればよい
	<表現>

	M
	 |B|B|0|1|B|B| 
	        ^
	 |B|1|0|0|B|B|B|
	     ^
	のようなMの、縦に並ぶ４つの要素(最初ならば「B」、「空白」、「B」、「空白」)
	を１つの要素とみなすことで、２つのテープは１つにまとめることが可能

	<処理>
	各テープのヘッドが指している数字を、状態として保存しておく

	チューリング機械Mに対し、テープ記号として0,1,B,#だけを使い、Mをシミュレート
	するチューリング機械M'が構成可能



5/13

comp(M~, x~) は帰納的。
証明
M~,x~は1テープチューリング機械のものとして一般性を失わない
計算状態を(q,u,v)とする。
q: 状態
u: ヘッドより左の記号列
v:ヘッド部分とそれより右の記号列
(q,u,v)は有限の値をとる。
(q,u,v)をゲーデル数にすることで、数字と計算状況を同一視。シミュレーションに必要な関数は
  halt-at-t?(M~,x~,t) = [M(x)はtステップ目の実行直後に正常終了する]
  config(M~,x~,t) = M(x)のtステップ目の実行後の計算状況
目標のcompは次のように定義できる
  time(M~,x~) = μ_t[halt-at-t?(M~,x~,t)]
  comp(M~,x~) = remove_B(get(config(M~,x~,time(M~x~))))

あとはhalt-at-t?とconfigが原始帰納的であることを示せばよい。
以下証明略(詳しくは教科書p.105-106)

これにより、すべてのチューリング機械計算可能関数は帰納的であることが言える。

μ演算の対象は原始帰納的述語に限られていた。
帰納的述語に対してμ演算wをした結果は帰納的関数か？？
→Yes
実は、このようにして得られた関数はチューリング機械計算可能であることが示せ
る。よって、帰納的関数といえる。

3.6 原始帰納的関数と帰納的関数
  両者の違いは、μ演算が構成要素に含まれるかどうか。
  「クリーネの標準形定理」
  μ演算もたった一度だけ使えば十分である。

  定理3.17　帰納的関数fは、適当な原始帰納的関数gと原始帰納的述語q?を用いて、
  次のように定義することができる。
    f(x) = g(x, μ[q?(x,y)])
  
  <証明>
    与えられた帰納的関数に対し、それを計算するチューリング機械M_fを考える(これは必ず存在する)。
      f(x) = comp(M_f~, godel(x))
    ここで、前の証明問題を見ると、compを構成する関数定義の中で、μ演算は一回しか行われていない。
    また、その他の関数はすべて原始帰納的関数によって構成されていたので、定理は示された。


