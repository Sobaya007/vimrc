module player.dodge.ContactPair;

import player;
import sbylib;
import collision;
import player.Particle;

struct ContactPair {
  private { 
    Particle particle;
    vec3 normal;
    float targetVel;
    vec3 tan, bin;
    float normalImpulse, tanImpulse, binImpulse;
  }

  this(CollisionInfo info, Particle particle) {
    this.normal = info.normal;
    this.particle = particle;
    auto dist = -info.normal.dot(particle.position - (info.vertex + info.normal * info.distance));//infoのdistanceはアテにならないのでここで再計算
    auto vn = particle.velocity.dot(info.normal);
    targetVel = vn * -0.6;
    auto sepVel = dist + 0.3;
    if (sepVel > 0) {
      sepVel *= 1 /  timeStep * 0.5;
      if (sepVel > targetVel) targetVel = sepVel;
    }

    if (info.normal.x == 0 && info.normal.z == 0) tan = vec3(1,0,0);
    else tan = info.normal.cross(vec3(0,1,0)).normalize;
    bin = info.normal.cross(tan).normalize;

    normalImpulse = tanImpulse = binImpulse = 0;
  }

  void solve() {
    auto vn = particle.velocity.dot(normal);
    auto oldImpulse = normalImpulse;
    auto newImpulse = targetVel - vn;
    normalImpulse += newImpulse;
    if (normalImpulse < 0) {
      normalImpulse = 0;
      newImpulse = normalImpulse - oldImpulse;
    }
    particle.velocity += newImpulse * normal;

    auto vt = particle.velocity.dot(tan);
    oldImpulse = tanImpulse;
    newImpulse = -vt;
    tanImpulse += newImpulse;

    auto bt = particle.velocity.dot(bin);
    auto oldImpulse2 = binImpulse;
    auto newImpulse2 = -bt;
    binImpulse += newImpulse2;

    if (binImpulse ^^2 + tanImpulse ^^2 > normalImpulse * .5) {
      auto rate = normalImpulse * .5 / sqrt(binImpulse^^2 + tanImpulse^^2);
      tanImpulse *= rate; binImpulse *= rate;
      newImpulse = tanImpulse - oldImpulse;
      newImpulse2 = binImpulse - oldImpulse2;
    }

    particle.velocity += tan * newImpulse + bin * newImpulse2;
  }

  bool finished() {
    return particle.velocity.dot(normal) > 0;
  }
}
