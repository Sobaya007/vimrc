module player.elastic.ElasticState;

import std.algorithm;
import std.container;
import collision;
import player.Input;
import player.elastic;
import player.PlayerState;
import player.Particle;
import player.PlayerDrawer;
import player.ParticleManager;
import player.Player;
import player.PlayerCollisionManager;
import sbylib.math;
import sbylib.physics3d;

static import sbylib.physics3d.Narrow;

class ElasticState : PlayerState {

  private ElasticSphere elasticSphere;
  private Player player;

  this(Player player) {
    this.player = player;
    elasticSphere = new ElasticSphere(player);
  }

  override void init() {
    elasticSphere.init();
  }

  override PlayerState step() {
    if (needleButton()) return player.createState!("Needle")();
    if (dodgeButton()) return player.createState!("Dodge")();
    return this;
  }

  override bool setCollisionInfo(CollisionObject thisObj, CollisionObject obj, ref Array!CollisionInfo myInfo, ref Array!CollisionInfo objInfo) {
    vec3 pushVec;
    vec3[] collisionPoints;
    return castSwitch !(
        (Tripolygon tri) {
          if(sbylib.physics3d.Narrow.EPA(thisObj.shape, tri.shape, pushVec, collisionPoints) == false) return false;
          foreach (point; collisionPoints) {
            myInfo ~= CollisionInfo();
            with(myInfo.back) {
              object = obj;
              distance = pushVec.length;
              normal = pushVec / distance;
              vertex = point;
            }
            objInfo ~= CollisionInfo();
            with(objInfo.back) {
              object = thisObj;
              distance = pushVec.length;
              normal = pushVec / distance;
              vertex = point;
            }
          }
          return true;
        },
        (CollisionCapsule capsuleObj) {
          auto sphere = cast(PhysicalSphere)thisObj.shape;
          auto capsule = cast(PhysicalCapsule)capsuleObj.shape;
          if (sbylib.physics3d.Narrow.collisionSphereCapsule(sphere, capsule, pushVec) == false) return false;
          pushVec = -pushVec;
          auto point = elasticSphere.support(pushVec);
          myInfo ~= CollisionInfo();
          with(myInfo.back) {
           object = obj;
           distance = pushVec.length;
           normal = pushVec / distance;
           vertex = point;
          }
          objInfo ~= CollisionInfo();
          with(objInfo.back) {
            object = thisObj;
            distance = pushVec.length;
            normal = pushVec / distance;
            vertex = point;
          }
          return true;
        },
        (CollisionObject colObj) {
          return false;
        }
    )(obj);
  }
}
