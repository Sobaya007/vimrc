module sbylib.physics3d.StringJoint;

import sbylib;

//２物体の距離を一定値以下にする
class StringJoint : Joint {

  private:
    vec3 aLocal, bLocal;
    float defaultLength;
    vec3 dir; //AからBに向かう向き
    float length;
    float targetVel; //dir方向の目的の速さ
    float totalImpulse = 0;
    float denominator;
    vec3 torqueUnitA, torqueUnitB;
    bool enabled; //このジョイントが有効かどうか
  public:

    this(RigidBody3D a, RigidBody3D b, vec3 aLocal, vec3 bLocal) {
      super(a, b);
      this.defaultLength = (getPos(b, bLocal) - getPos(a, aLocal)).length;
      this.aLocal = aLocal;
      this.bLocal = bLocal;
    }

    override void prepareSolve() {
      auto v = getPos(b, bLocal) - getPos(a, aLocal);
      length = v.length;
      if (length > 0) this.dir = v / length;
      else this.dir = vec3(0);
      enabled = false;
      if (length > defaultLength) {
        targetVel = -(length - defaultLength);
        enabled = true;
      }

      auto ra = getPos(a, aLocal) - a.shape.pos;
      auto rb = getPos(b, bLocal) - b.shape.pos;
      auto torqueA = cross(ra, dir);
      auto torqueB = cross(rb, dir);
      torqueUnitA = a.worldInertiaInv * torqueA;
      torqueUnitB = b.worldInertiaInv * torqueB;
      denominator = 1 / (a.massInv + b.massInv + dot(dir, cross(torqueUnitA, ra) + cross(torqueUnitB, rb)));
    }

    override void solve() {
      if (!enabled) return;
      auto velD = dot(b.getVelocity(getPos(b, bLocal)) - a.getVelocity(getPos(a, aLocal)), dir);
      auto impulse = (targetVel - velD) * denominator;
      auto oldImpulse = totalImpulse;
      totalImpulse += impulse;
      if (totalImpulse > 0) {
        totalImpulse = 0;
        impulse = totalImpulse - oldImpulse;
      }
      auto force = dir * impulse;
      a.shape.lVel -= force * a.massInv;
      a.shape.aVel -= torqueUnitA * impulse;
      b.shape.lVel += force * b.massInv;
      b.shape.aVel += torqueUnitB * impulse;
    }
}
