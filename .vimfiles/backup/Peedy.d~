module enemy.Peedy;

import sbylib;
import enemy.GameAI;

class Peedy : GameAI {
	static{
	}
	private bool initFlag = false;
	private float size = 0.5;//図形の半辺の長さ
	uint[][6] index; //どの頂点で図形を構成するか
	vec4[8] vertex;  //頂点
	vec4[] ver;      //連結されてる体の頂点
	int bodynum = 15;//連結されてる体の個数
	vec3[] bodypos; //各体の中心座標リスト
	vec3[] dir;     //各体の速度ベクトル
	CustomObject custom;

	this(Material mat = null)  {
		if (mat is null){
			mat = new Material;
		}
		TextureObject tex = new TextureObject(SbyWorld.rootPath ~ "Resource/traP.png");
		// todo: change here to triangle_strip
		index = [
			[0,1,2,3], //奥
			[6,7,4,5], //手前
			[2,3,6,7], //上
			[4,5,0,1], //下
			[5,7,1,3], //左
			[0,2,4,6]  //右
		];
		vertex = [
			vec4(-1,-1,-1,1),
			vec4(+1,-1,-1,1),
			vec4(-1,+1,-1,1),
			vec4(+1,+1,-1,1),
			vec4(-1,-1,1,1),
			vec4(+1,-1,1,1),
			vec4(-1,+1,1,1),
			vec4(+1,+1,1,1)
		];
		foreach(ref i; vertex) {
		    i[0] *= size;
		    i[1] *= size;
		    i[2] *= size;
		}
		vec2[4] tc = [
			vec2(0,0),
			vec2(1,0),
			vec2(0,1),
			vec2(1,1)
		];

		vec4[] vertex2;
		foreach(j ; 0..bodynum){
		    auto dj = to!double(j);
		    dj *= size * 3;  //縮尺を変更
		    auto tempvec3 = vec3(dj,0.0,0.0); //(連結されている)各体の中心の座標
		    foreach (i; 0..6) {
			    auto tempvec4 = ttof(tempvec3); //４次元ベクトルにする
			    vertex2 ~= vertex[index[i][0]] + tempvec4;
			    vertex2 ~= vertex[index[i][1]] + tempvec4;
			    vertex2 ~= vertex[index[i][2]] + tempvec4;
			    vertex2 ~= vertex[index[i][2]] + tempvec4;
			    vertex2 ~= vertex[index[i][1]] + tempvec4;
			    vertex2 ~= vertex[index[i][3]] + tempvec4;
		    }
		    bodypos ~= tempvec3;  //各体の中心の座標を格納
		    dir ~= vec3(1.0,0.0,0.0);
		}
		vec2[] tc2;
		foreach (i ; 0..bodynum){
		    foreach (j; 0..6) {
			    tc2 ~= tc[0];
			    tc2 ~= tc[1];
			    tc2 ~= tc[2];
			    tc2 ~= tc[2];
			    tc2 ~= tc[1];
			    tc2 ~= tc[3];
		    }
		}
		//ここで描画
	    alias conv = reduce!((a,b) => a ~ b.array);
	    custom = new CustomObject(mat, ShaderStore.getShader("TextureShow"), Prim.Triangle);
	    custom.beginMesh;
	    custom.addAttribute!(2, "mTexcoord")(conv(cast(float[])[], tc2), GpuSendFrequency.Static);
	    custom.addAttribute!(4, "mVertex")(conv(cast(float[])[], vertex2), GpuSendFrequency.Static);
	    custom.setIndex(iota(cast(uint)vertex2.length).array.reverse, GpuSendFrequency.Static);
	    custom.setTexture(tex);
		custom.addDynamicUniformMatrix!(4, "mWorld")({return this.getWorldMatrix.array;});
		custom.addDynamicUniformMatrix!(4, "mViewProj")({return SbyWorld.currentCamera.getViewProjectionMatrix().array;});
	    custom.endMesh;
	}

	void move(){
	    pos(getPos() + dir[0] * 0.01);
	}

	override bool draw() {
		move();
		custom.draw();
		return true;
	}

	override bool step(){
		return true;
	}

}
