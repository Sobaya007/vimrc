module sbylib.physics3d.PhysicalCapsule;

import sbylib;
import sbylib.physics3d.Shape;

class PhysicalCapsule : Shape {
  private:
    float radius;
    float len;
    vec3 s, e;
  public:

    vec3 getStart() {
      return s;
    }

    vec3 getEnd() {
      return e;
    }

    float getRadius() {
      return radius;
    }

    this(float len, float r) {
      this.len = len;
      this.radius = r;
      auto v = vec3(1,0,0) * len / 2;
      s = v;
      e = -v;
      super();
    }

    this(vec3 s, vec3 e, float r) {
      this.s = s;
      this.e = e;
      this.radius = r;
      this.len = (e-s).length;

      super();
      Position = (s+e)/2;
      Orientation = quat.rotFromTo(vec3(1,0,0), (s-e).normalize);
    }
override:

    void update() {
      super.update;
      auto v = rotate(vec3(1,0,0), Orientation) * len / 2;
      s = Position + v;
      e = Position - v;
    }

    float computeVolume() {
      return radius ^^3 * PI * 4 / 3 + PI * radius^^2 * (e - s).length;
    }

    mat3 computeInertiaTensor() {
      return mat3.scale(vec3(radius^^2 * 2 / 5)); //まだやってない
    }

    CustomObject createCustomObject() {
      auto custom =  new Capsule(s, e, radius).getCustomObject;
      custom.setUniformMatrix!(4, "mWorld")(mat4.identity.array);
      custom.addDynamicUniform!(4, "mViewProj")({return SbyWorld.currentCamera.getViewProjectionMatrix.array;});
      return custom;
    }

    vec3 getMaxPoint() {
      return vec3(max(s.x, e.x), max(s.y, e.y), max(s.z, e.z)) + vec3(radius);
    }

    vec3 getMinPoint() {
      return vec3(min(s.x, e.x), min(s.y, e.y), min(s.z, e.z)) - vec3(radius);
    }

    void updateCustomObject(CustomObject custom) {
      mat4 mWorld = mat4.translate(Position) * Orientation.toMatrix4;
      custom.setUniformMatrix!(4,"mWorld")(mWorld.array);
    }

    vec3 support(vec3 d) {

      if (dot(d, (e-s).normalize).abs < .01) return Position + d * radius;
      return (dot(s, d) < dot(e, d) ? e : s) + d * radius;
    }

    Face supportFace(vec3 d) {

      vec3 getVertical(vec3 v) {
        if (v.x == 0 && v.y == 0) {
          if (v.z == 0) assert(false);
          return vec3(1,0,0);
        }
        return v.cross(vec3(0,0,1));
      }

      if (dot(d, (e-s).normalize).abs < .01) {
        auto v = (e - s).normalize.cross(d);
        Face face = new Face();
        face.normal = d;
        void set(vec3 p) {
          Vertex vertex =  new Vertex(p);
          vertex.worldPosition = vertex.position;
          vertex.faces ~= face;
          face.vertices ~= vertex;
        }
        set(s + d * radius + 0.1 * v);
        set(s + d * radius - 0.1 * v);
        set(e + d * radius - 0.1 * v);
        set(e + d * radius + 0.1 * v);
        return face;
      }

      //微小面積の面を一応作っておくことにする
      //サポート頂点のまわりに半径0.1の五角形を作る
      auto v = getVertical(d) * 0.2;
      Face face = new Face();
      auto p = support(d);
      quat rot = quat.createAxisAngle(d, 2 * PI / 5);
      foreach (i; 0..5) {
        Vertex vertex =  new Vertex(p + v);
        vertex.worldPosition = vertex.position;
        vertex.faces ~= face;
        face.vertices ~= vertex;
        face.normal = d;

        v = rotate(v, rot);
      }
      return face;
    }
}
